

;
; ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
; บ	This file is generated by The Interactive Disassembler (IDA)	    บ
; บ	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    บ
; บ			 Licensed to: Freeware version			    บ
; ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
;
; Input	MD5   :	5255D2DE1B5B493219667BB79B0861EB

; File Name   :	F:\program
; Format      :	ELF (Executable)
; Interpreter '/lib/ld-linux.so.2'
; Needed Library 'libc.so.6'
;
; Source File :	'crtstuff.c'
; Source File :	'program.c'
; Source File :	'crtstuff.c'

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type:	Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use32
assume cs:_init
;org 8048424h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _init_proc
_init_proc proc	near
push	ebx		; _init
sub	esp, 8
call	__x86_get_pc_thunk_bx
add	ebx, 3BD3h
mov	eax, [ebx-4]
test	eax, eax
jz	short loc_8048442
call	__gmon_start__

loc_8048442:
add	esp, 8
pop	ebx
retn
_init_proc endp

_init ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use32
assume cs:_plt
;org 8048450h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
dd 4 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _printf. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___stack_chk_fail. PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _fwrite. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _malloc. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS	KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _memset. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _putchar.	PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___isoc99_scanf. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___assert_fail. PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
_plt ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
; Segment alignment 'qword' can not be represented in assembly
_plt_got segment para public 'CODE' use32
assume cs:_plt_got
;org 8048500h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION __gmon_start__. PRESS KEYPAD "+" TO EXPAND]
align 4
_plt_got ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use32
assume cs:_text
;org 8048510h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _start
_start proc near
xor	ebp, ebp
pop	esi
mov	ecx, esp
and	esp, 0FFFFFFF0h
push	eax
push	esp
push	edx
push	offset __libc_csu_fini
push	offset __libc_csu_init
push	ecx
push	esi
push	offset main
call	___libc_start_main
hlt
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
_start endp




public __x86_get_pc_thunk_bx
__x86_get_pc_thunk_bx proc near
mov	ebx, [esp+0]
retn
__x86_get_pc_thunk_bx endp

align 10h


; Attributes: bp-based frame

deregister_tm_clones proc near
mov	eax, 804C03Fh
sub	eax, 804C03Ch
cmp	eax, 6
jbe	short locret_8048579
mov	eax, 0
test	eax, eax
jz	short locret_8048579
push	ebp
mov	ebp, esp
sub	esp, 14h
push	804C03Ch
call	eax
add	esp, 10h
leave

locret_8048579:
rep retn
deregister_tm_clones endp ; sp =  4

align 10h


; Attributes: bp-based frame

register_tm_clones proc	near
mov	eax, 804C03Ch
sub	eax, 804C03Ch
sar	eax, 2
mov	edx, eax
shr	edx, 1Fh
add	eax, edx
sar	eax, 1
jz	short locret_80485B3
mov	edx, 0
test	edx, edx
jz	short locret_80485B3
push	ebp
mov	ebp, esp
sub	esp, 10h
push	eax
push	804C03Ch
call	edx
add	esp, 10h
leave

locret_80485B3:
rep retn
register_tm_clones endp	; sp =	4

align 10h


; Attributes: bp-based frame

__do_global_dtors_aux proc near
cmp	ds:completed_7200, 0
jnz	short locret_80485DC
push	ebp
mov	ebp, esp
sub	esp, 8
call	deregister_tm_clones
mov	ds:completed_7200, 1
leave

locret_80485DC:
rep retn
__do_global_dtors_aux endp ; sp	=  4

align 10h


; Attributes: bp-based frame

frame_dummy proc near
mov	eax, offset __JCR_LIST__
mov	edx, [eax]
test	edx, edx
jnz	short loc_80485F0

loc_80485EB:
jmp	short register_tm_clones
align 10h

loc_80485F0:
mov	edx, 0
test	edx, edx
jz	short loc_80485EB
push	ebp
mov	ebp, esp
sub	esp, 14h
push	eax
call	edx
add	esp, 10h
leave
jmp	register_tm_clones
frame_dummy endp



; Attributes: bp-based frame

public main
main proc near

arg_0= dword ptr  4

lea	ecx, [esp+arg_0]
and	esp, 0FFFFFFF0h
push	dword ptr [ecx-4]
push	ebp
mov	ebp, esp
push	ecx
sub	esp, 4

loc_804861C:
call	initialise
jmp	short loc_804863D

loc_8048623:
call	display
call	manage_input
movzx	eax, ds:is_clicked
test	al, al
jz	short loc_804863D
call	process

loc_804863D:
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 0Ch
push	eax
call	is_game_over
add	esp, 10h
test	al, al
jz	short loc_8048623
call	display
call	game_over
jmp	short loc_804861C
main endp



; Attributes: bp-based frame

public display
display	proc near

var_18B= byte ptr -18Bh
var_18A= byte ptr -18Ah
var_189= byte ptr -189h
var_188= byte ptr -188h
var_187= byte ptr -187h
var_186= byte ptr -186h
var_185= byte ptr -185h
var_184= dword ptr -184h
var_180= dword ptr -180h
var_17A= dword ptr -17Ah
var_1C=	dword ptr -1Ch
var_18=	dword ptr -18h
var_C= dword ptr -0Ch

push	ebp
mov	ebp, esp
push	edi
push	esi
push	ebx
sub	esp, 18Ch
mov	eax, large gs:14h
mov	[ebp+var_1C], eax
xor	eax, eax
mov	[ebp+var_18B], 6
mov	[ebp+var_18A], 0Eh
lea	eax, [ebp+var_17A]
mov	ebx, offset asc_804A2A0	; "	    "
mov	edx, 15Eh
mov	ecx, [ebx]
mov	[eax], ecx
mov	ecx, [ebx+edx-4]
mov	[eax+edx-4], ecx
lea	edi, [eax+4]
and	edi, 0FFFFFFFCh
sub	eax, edi
sub	ebx, eax
add	edx, eax
and	edx, 0FFFFFFFCh
mov	eax, edx
shr	eax, 2
mov	esi, ebx
mov	ecx, eax
rep movsd
movzx	eax, ds:current_pos
shr	al, 3
mov	[ebp+var_189], al
movzx	eax, ds:current_pos
and	eax, 7
mov	[ebp+var_188], al
movzx	eax, ds:cur_player
test	al, al
jz	short loc_80486F0
mov	eax, offset aTrue ; "TRUE"
jmp	short loc_80486F5

loc_80486F0:		; "FALSE"
mov	eax, offset aFalse

loc_80486F5:
sub	esp, 8
push	eax
push	offset aCur_playerS ; "cur_player   == %s\n"
call	_printf
add	esp, 10h
movzx	eax, ds:has_selected
test	al, al
jz	short loc_8048718
mov	eax, offset aTrue ; "TRUE"
jmp	short loc_804871D

loc_8048718:		; "FALSE"
mov	eax, offset aFalse

loc_804871D:
sub	esp, 8
push	eax
push	offset aHas_selectedS ;	"has_selected == %s\n"
call	_printf
add	esp, 10h
movzx	eax, ds:is_clicked
test	al, al
jz	short loc_8048740
mov	eax, offset aTrue ; "TRUE"
jmp	short loc_8048745

loc_8048740:		; "FALSE"
mov	eax, offset aFalse

loc_8048745:
sub	esp, 8
push	eax
push	offset aIs_clickedS ; "is_clicked   == %s\n"
call	_printf
add	esp, 10h
movzx	eax, ds:selected_pos
movzx	eax, al
and	eax, 7
mov	edx, eax
movzx	eax, ds:selected_pos
shr	al, 3
movzx	eax, al
sub	esp, 4
push	edx
push	eax
push	offset aSelected_posDD ; "selected_pos == (%d,%d);\n"
call	_printf
add	esp, 10h
movzx	eax, ds:current_pos
movzx	eax, al
and	eax, 7
mov	edx, eax
movzx	eax, ds:current_pos
shr	al, 3
movzx	eax, al
sub	esp, 4
push	edx
push	eax
push	offset aCurrent_posDD ;	"current_pos  == (%d,%d);\n"
call	_printf
add	esp, 10h
movzx	eax, ds:en_passant_flag
movzx	eax, al
sub	esp, 8
push	eax
push	offset aEn_paasant_fla ; "en_paasant_flag  == %d;\n"
call	_printf
add	esp, 10h
movzx	eax, ds:castle_flag
movzx	eax, al
sub	esp, 8
push	eax
push	offset aCastle_flagD ; "castle_flag	 == %d;\n"
call	_printf
add	esp, 10h
movzx	eax, [ebp+var_18B]
shl	eax, 3
mov	[ebp+var_184], eax
jmp	loc_8048BD5

loc_80487FD:
mov	[ebp+var_180], 0
jmp	loc_8048BA8

loc_804880C:
movzx	edi, [ebp+var_18B]
mov	eax, [ebp+var_184]
cdq
idiv	edi
mov	[ebp+var_187], al
movzx	ebx, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	ebx
mov	[ebp+var_186], al
movzx	eax, [ebp+var_186]
movzx	edx, al
movzx	eax, [ebp+var_187]
movzx	eax, al
sub	esp, 8
push	edx
push	eax
call	to_pos
add	esp, 10h
mov	[ebp+var_185], al
movzx	ecx, [ebp+var_18B]
mov	eax, [ebp+var_184]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jnz	short loc_804889D
movzx	ecx, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jnz	short loc_804889D
sub	esp, 0Ch
push	2Bh		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_804889D:
movzx	ecx, [ebp+var_18B]
mov	eax, [ebp+var_184]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jnz	loc_8048943
movzx	eax, [ebp+var_187]
cmp	al, [ebp+var_189]
jz	short loc_80488DB
movsx	eax, [ebp+var_187]
movsx	edx, [ebp+var_189]
add	edx, 1
cmp	eax, edx
jnz	short loc_8048912

loc_80488DB:
movzx	eax, [ebp+var_186]
cmp	al, [ebp+var_188]
jnz	short loc_8048912
movzx	eax, ds:has_selected
test	al, al
jz	short loc_80488FC
mov	eax, 23h
jmp	short loc_8048901

loc_80488FC:
mov	eax, 40h

loc_8048901:
sub	esp, 0Ch
push	eax		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048912:
mov	eax, [ebp+var_180]
and	eax, 1
test	eax, eax
jz	short loc_8048931
sub	esp, 0Ch
push	20h		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048931:
sub	esp, 0Ch
push	2Dh		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048943:
movzx	ecx, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jnz	loc_80489E9
movzx	eax, [ebp+var_186]
cmp	al, [ebp+var_188]
jz	short loc_8048981
movsx	eax, [ebp+var_186]
movsx	edx, [ebp+var_188]
add	edx, 1
cmp	eax, edx
jnz	short loc_80489B8

loc_8048981:
movzx	eax, [ebp+var_187]
cmp	al, [ebp+var_189]
jnz	short loc_80489B8
movzx	eax, ds:has_selected
test	al, al
jz	short loc_80489A2
mov	eax, 23h
jmp	short loc_80489A7

loc_80489A2:
mov	eax, 40h

loc_80489A7:
sub	esp, 0Ch
push	eax		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_80489B8:
mov	eax, [ebp+var_184]
and	eax, 1
test	eax, eax
jz	short loc_80489D7
sub	esp, 0Ch
push	20h		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_80489D7:
sub	esp, 0Ch
push	7Ch		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_80489E9:
mov	eax, [ebp+var_180]
add	eax, 1
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jz	short loc_8048A63
mov	eax, [ebp+var_180]
lea	edx, [eax-1]
movzx	eax, [ebp+var_18A]
add	eax, edx
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jz	short loc_8048A63
mov	eax, [ebp+var_180]
add	eax, 2
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jz	short loc_8048A63
mov	eax, [ebp+var_180]
lea	edx, [eax-2]
movzx	eax, [ebp+var_18A]
add	eax, edx
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx
test	eax, eax
jnz	loc_8048AF5

loc_8048A63:
movzx	eax, ds:current_pos
cmp	[ebp+var_185], al
jnz	short loc_8048A9A
movzx	eax, ds:has_selected
test	al, al
jz	short loc_8048A84
mov	eax, 23h
jmp	short loc_8048A89

loc_8048A84:
mov	eax, 40h

loc_8048A89:
sub	esp, 0Ch
push	eax		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048A9A:
movzx	eax, ds:selected_pos
cmp	[ebp+var_185], al
jnz	short loc_8048ABB
sub	esp, 0Ch
push	2Ah		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048ABB:
mov	edx, ds:are_marked
movzx	eax, [ebp+var_185]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_8048AE3
sub	esp, 0Ch
push	24h		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048AE3:
sub	esp, 0Ch
push	20h		; int
call	_putchar
add	esp, 10h
jmp	loc_8048BA1

loc_8048AF5:
mov	edx, ds:cells_type
movzx	eax, [ebp+var_185]
add	eax, edx
movzx	eax, byte ptr [eax]
movzx	ebx, al
movzx	ecx, [ebp+var_18B]
movzx	esi, [ebp+var_18B]
mov	eax, [ebp+var_184]
cdq
idiv	esi
mov	eax, edx
sub	ecx, eax
mov	eax, ecx
lea	ecx, [eax-1]
movzx	esi, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	esi
mov	eax, edx
lea	esi, [eax-3]
mov	eax, ecx
shl	eax, 2
add	eax, ecx
add	eax, eax
imul	edx, ebx, 32h
add	eax, edx
lea	edi, [ebp+var_18]
add	eax, edi
add	eax, esi
sub	eax, 162h
movzx	eax, byte ptr [eax]
cmp	al, 20h
jnz	short loc_8048B6F
sub	esp, 0Ch
push	20h		; int
call	_putchar
add	esp, 10h
jmp	short loc_8048BA1

loc_8048B6F:
mov	edx, ds:cells_side
movzx	eax, [ebp+var_185]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_8048B94
sub	esp, 0Ch
push	4Fh		; int
call	_putchar
add	esp, 10h
jmp	short loc_8048BA1

loc_8048B94:
sub	esp, 0Ch
push	58h		; int
call	_putchar
add	esp, 10h

loc_8048BA1:
add	[ebp+var_180], 1

loc_8048BA8:
movzx	eax, [ebp+var_18A]
shl	eax, 3
add	eax, 1
cmp	eax, [ebp+var_180]
jg	loc_804880C
sub	[ebp+var_184], 1
sub	esp, 0Ch
push	0Ah		; int
call	_putchar
add	esp, 10h

loc_8048BD5:
cmp	[ebp+var_184], 0
jns	loc_80487FD
nop
mov	eax, [ebp+var_1C]
xor	eax, large gs:14h
jz	short loc_8048BF4
call	___stack_chk_fail

loc_8048BF4:
lea	esp, [ebp-0Ch]
pop	ebx
pop	esi
pop	edi
pop	ebp
retn
display	endp



; Attributes: bp-based frame

public manage_input
manage_input proc near

var_10=	byte ptr -10h
var_F= byte ptr	-0Fh
var_E= byte ptr	-0Eh
var_C= dword ptr -0Ch

push	ebp
mov	ebp, esp
sub	esp, 18h
mov	eax, large gs:14h
mov	[ebp+var_C], eax
xor	eax, eax
movzx	eax, ds:current_pos
shr	al, 3
mov	[ebp+var_10], al
movzx	eax, ds:current_pos
and	eax, 7
mov	[ebp+var_F], al
mov	ds:is_clicked, 0
sub	esp, 0Ch
push	offset aGetInputAswdFo ; "Get input (aswd for direction, f for cl"...
call	_printf
add	esp, 10h
sub	esp, 8
lea	eax, [ebp-0Eh]
push	eax
push	offset aS	; "%s"
call	___isoc99_scanf
add	esp, 10h
movzx	eax, [ebp+var_E]
movsx	eax, al
sub	eax, 61h	; switch 23 cases
cmp	eax, 16h
ja	loc_8048CEB	; default
mov	eax, ds:off_804A450[eax*4]
jmp	eax		; switch jump

loc_8048C6E:		; case 0x61
movsx	eax, [ebp+var_F]
lea	edx, [eax+7]
mov	eax, edx
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax
and	edx, 7
sub	edx, eax
mov	eax, edx
mov	[ebp+var_F], al
jmp	short loc_8048D03

loc_8048C8B:		; case 0x64
movsx	eax, [ebp+var_F]
lea	edx, [eax+9]
mov	eax, edx
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax
and	edx, 7
sub	edx, eax
mov	eax, edx
mov	[ebp+var_F], al
jmp	short loc_8048D03

loc_8048CA8:		; case 0x73
movsx	eax, [ebp+var_10]
lea	edx, [eax+7]
mov	eax, edx
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax
and	edx, 7
sub	edx, eax
mov	eax, edx
mov	[ebp+var_10], al
jmp	short loc_8048D03

loc_8048CC5:		; case 0x77
movsx	eax, [ebp+var_10]
lea	edx, [eax+9]
mov	eax, edx
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax
and	edx, 7
sub	edx, eax
mov	eax, edx
mov	[ebp+var_10], al
jmp	short loc_8048D03

loc_8048CE2:		; case 0x66
mov	ds:is_clicked, 1
jmp	short loc_8048D03

loc_8048CEB:		; default
mov	eax, ds:stderr@@GLIBC_2_0
push	eax		; FILE *
push	1Ah		; n
push	1		; size
push	offset aCannotRecognis ; "cannot recognise the input"
call	_fwrite
add	esp, 10h
nop

loc_8048D03:
movzx	eax, [ebp+var_F]
movzx	edx, al
movzx	eax, [ebp+var_10]
movzx	eax, al
sub	esp, 8
push	edx
push	eax
call	to_pos
add	esp, 10h
mov	ds:current_pos,	al
nop
mov	eax, [ebp+var_C]
xor	eax, large gs:14h
jz	short locret_8048D35
call	___stack_chk_fail

locret_8048D35:
leave
retn
manage_input endp



; Attributes: bp-based frame

public promote_pawn
promote_pawn proc near

var_E= byte ptr	-0Eh
var_C= dword ptr -0Ch

push	ebp
mov	ebp, esp
sub	esp, 18h
mov	eax, large gs:14h
mov	[ebp+var_C], eax
xor	eax, eax
sub	esp, 0Ch
push	offset aTheCurrentPawn ; "The current pawn is promoting... "
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset aWhichTypeThatY ; "Which	type that you want your	pawn to	b"...
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset aAKnightSBishop ; "a(knight) s(bishop) d(rook) w(queen) : "...
call	_printf
add	esp, 10h
sub	esp, 8
lea	eax, [ebp-0Eh]
push	eax
push	offset aS	; "%s"
call	___isoc99_scanf
add	esp, 10h
movzx	eax, [ebp+var_E]
movsx	eax, al
cmp	eax, 64h
jz	short loc_8048DB7
cmp	eax, 64h
jg	short loc_8048DA4
cmp	eax, 61h
jz	short loc_8048DB0
jmp	short loc_8048DCC

loc_8048DA4:
cmp	eax, 73h
jz	short loc_8048DC5
cmp	eax, 77h
jz	short loc_8048DBE
jmp	short loc_8048DCC

loc_8048DB0:
mov	eax, 2
jmp	short loc_8048DE8

loc_8048DB7:
mov	eax, 3
jmp	short loc_8048DE8

loc_8048DBE:
mov	eax, 4
jmp	short loc_8048DE8

loc_8048DC5:
mov	eax, 5
jmp	short loc_8048DE8

loc_8048DCC:
mov	eax, ds:stderr@@GLIBC_2_0
push	eax		; FILE *
push	1Ah		; n
push	1		; size
push	offset aCannotRecognis ; "cannot recognise the input"
call	_fwrite
add	esp, 10h
mov	eax, 0FFFFFFFFh

loc_8048DE8:
mov	edx, [ebp+var_C]
xor	edx, large gs:14h
jz	short locret_8048DF9
call	___stack_chk_fail

locret_8048DF9:
leave
retn
promote_pawn endp



; Attributes: bp-based frame

public game_over
game_over proc near
push	ebp
mov	ebp, esp
sub	esp, 8
movzx	eax, ds:current_pos
movzx	ecx, al
movzx	eax, ds:current_pos
movzx	edx, al
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 4
push	ecx
push	edx
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jz	short loc_8048E9B
sub	esp, 0Ch
push	offset asc_804A528 ; "\n"
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset asc_804A52A ; "*****************************"
call	_puts
add	esp, 10h
movzx	eax, ds:cur_player
test	al, al
jnz	short loc_8048E63
mov	eax, 58h
jmp	short loc_8048E68

loc_8048E63:
mov	eax, 4Fh

loc_8048E68:
sub	esp, 8
push	eax
push	offset aGameOverPlayer ; "* Game Over Player %c	win. *\n"
call	_printf
add	esp, 10h
sub	esp, 0Ch
push	offset asc_804A52A ; "*****************************"
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset asc_804A566 ; "\n\n\n\n"
call	_puts
add	esp, 10h
jmp	short loc_8048EEB

loc_8048E9B:
sub	esp, 0Ch
push	offset asc_804A528 ; "\n"
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset asc_804A56B ; "***********************"
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset aGameOverStalem ; "* Game Over Stalemate	*"
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset asc_804A56B ; "***********************"
call	_puts
add	esp, 10h
sub	esp, 0Ch
push	offset asc_804A566 ; "\n\n\n\n"
call	_puts
add	esp, 10h

loc_8048EEB:
nop
leave
retn
game_over endp



; Attributes: bp-based frame

public initialise
initialise proc	near
push	ebp
mov	ebp, esp
sub	esp, 8
mov	ds:cur_player, 0
mov	ds:has_selected, 0
mov	ds:is_clicked, 0
mov	ds:en_passant_flag, 0FFh
mov	ds:castle_flag,	0
mov	ds:selected_pos, 0FFh
mov	ds:current_pos,	24h
sub	esp, 0Ch
push	40h		; size
call	_malloc
add	esp, 10h
mov	ds:cells_type, eax
mov	eax, ds:cells_type
test	eax, eax
jnz	short loc_8048F59
push	offset __PRETTY_FUNCTION___2748	; "initialise"
push	0F3h
push	offset aProgram_c ; "program.c"
push	offset aCells_typeNull ; "cells_type !=	NULL"
call	___assert_fail

loc_8048F59:
mov	eax, ds:cells_type
sub	esp, 4
push	40h		; size_t
push	0		; int
push	eax		; void *
call	_memset
add	esp, 10h
mov	eax, ds:cells_type
add	eax, 8
sub	esp, 4
push	8		; size_t
push	1		; int
push	eax		; void *
call	_memset
add	esp, 10h
mov	eax, ds:cells_type
add	eax, 30h
sub	esp, 4
push	8		; size_t
push	1		; int
push	eax		; void *
call	_memset
add	esp, 10h
mov	edx, ds:cells_type
mov	eax, ds:cells_type
add	eax, 38h
mov	byte ptr [eax],	4
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+1]
mov	eax, ds:cells_type
add	eax, 39h
mov	byte ptr [eax],	2
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+2]
mov	eax, ds:cells_type
add	eax, 3Ah
mov	byte ptr [eax],	3
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+3]
mov	eax, ds:cells_type
add	eax, 3Bh
mov	byte ptr [eax],	5
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+4]
mov	eax, ds:cells_type
add	eax, 3Ch
mov	byte ptr [eax],	6
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+5]
mov	eax, ds:cells_type
add	eax, 3Dh
mov	byte ptr [eax],	3
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+6]
mov	eax, ds:cells_type
add	eax, 3Eh
mov	byte ptr [eax],	2
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	eax, ds:cells_type
lea	edx, [eax+7]
mov	eax, ds:cells_type
add	eax, 3Fh
mov	byte ptr [eax],	4
movzx	eax, byte ptr [eax]
mov	[edx], al
sub	esp, 0Ch
push	40h		; size
call	_malloc
add	esp, 10h
mov	ds:are_marked, eax
mov	eax, ds:are_marked
test	eax, eax
jnz	short loc_8049090
push	offset __PRETTY_FUNCTION___2748	; "initialise"
push	101h
push	offset aProgram_c ; "program.c"
push	offset aAre_markedNull ; "are_marked !=	NULL"
call	___assert_fail

loc_8049090:
mov	eax, ds:are_marked
sub	esp, 4
push	40h		; size_t
push	0		; int
push	eax		; void *
call	_memset
add	esp, 10h
sub	esp, 0Ch
push	40h		; size
call	_malloc
add	esp, 10h
mov	ds:cells_side, eax
mov	eax, ds:cells_side
test	eax, eax
jnz	short loc_80490D9
push	offset __PRETTY_FUNCTION___2748	; "initialise"
push	105h
push	offset aProgram_c ; "program.c"
push	offset aCells_sideNull ; "cells_side !=	NULL"
call	___assert_fail

loc_80490D9:
mov	eax, ds:cells_side
sub	esp, 4
push	20h		; size_t
push	0		; int
push	eax		; void *
call	_memset
add	esp, 10h
mov	eax, ds:cells_side
add	eax, 20h
sub	esp, 4
push	20h		; size_t
push	1		; int
push	eax		; void *
call	_memset
add	esp, 10h
nop
leave
retn
initialise endp



; Attributes: bp-based frame

public is_game_over
is_game_over proc near

var_1C=	byte ptr -1Ch
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
arg_0= dword ptr  8

push	ebp
mov	ebp, esp
sub	esp, 28h
mov	eax, [ebp+arg_0]
mov	[ebp+var_1C], al
movzx	eax, ds:cur_player
mov	[ebp+var_9], al
movzx	eax, [ebp+var_1C]
mov	ds:cur_player, al
mov	[ebp+var_C], 1
mov	[ebp+var_B], 0
jmp	loc_80491CC

loc_8049135:
mov	edx, ds:cells_type
movzx	eax, [ebp+var_B]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_80491C2
mov	edx, ds:cells_side
movzx	eax, [ebp+var_B]
add	eax, edx
movzx	eax, byte ptr [eax]
cmp	al, [ebp+var_1C]
jnz	short loc_80491C2
mov	[ebp+var_A], 0
jmp	short loc_80491BC

loc_8049162:
movzx	ecx, [ebp+var_A]
movzx	edx, [ebp+var_B]
movzx	eax, [ebp+var_1C]
sub	esp, 4
push	ecx
push	edx
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jnz	short loc_804919B
movzx	edx, [ebp+var_A]
movzx	eax, [ebp+var_B]
sub	esp, 4
push	0
push	edx
push	eax
call	legal_move
add	esp, 10h
test	al, al
jnz	short loc_80491A2

loc_804919B:
mov	eax, 1
jmp	short loc_80491A7

loc_80491A2:
mov	eax, 0

loc_80491A7:
mov	edx, eax
movzx	eax, [ebp+var_C]
and	eax, edx
mov	[ebp+var_C], al
movzx	eax, [ebp+var_A]
add	eax, 1
mov	[ebp+var_A], al

loc_80491BC:
cmp	[ebp+var_A], 3Fh
jbe	short loc_8049162

loc_80491C2:
movzx	eax, [ebp+var_B]
add	eax, 1
mov	[ebp+var_B], al

loc_80491CC:
cmp	[ebp+var_B], 3Fh
jbe	loc_8049135
movzx	eax, [ebp+var_9]
mov	ds:cur_player, al
movzx	eax, [ebp+var_C]
leave
retn
is_game_over endp



; Attributes: bp-based frame

public process
process	proc near

var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_4= dword ptr -4

push	ebp
mov	ebp, esp
push	ebx
sub	esp, 14h
movzx	eax, ds:current_pos
cmp	al, 3Fh
jbe	short loc_8049210
push	offset __PRETTY_FUNCTION___2764
push	118h
push	offset aProgram_c ; "program.c"
push	offset a0Current_posCu ; "0 <= current_pos && current_pos < BOARD"...
call	___assert_fail

loc_8049210:
movzx	eax, ds:has_selected
test	al, al
jnz	loc_80492D1
movzx	eax, ds:current_pos
movzx	eax, al
sub	esp, 0Ch
push	eax
call	is_own_piece
add	esp, 10h
test	al, al
jz	loc_8049407
mov	[ebp+var_A], 0
jmp	short loc_80492B3

loc_8049243:
mov	edx, ds:are_marked
movzx	eax, [ebp+var_A]
lea	ebx, [edx+eax]
movzx	ecx, [ebp+var_A]
movzx	eax, ds:current_pos
movzx	edx, al
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 4
push	ecx
push	edx
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jnz	short loc_80492A2
movzx	edx, [ebp+var_A]
movzx	eax, ds:current_pos
movzx	eax, al
sub	esp, 4
push	0
push	edx
push	eax
call	legal_move
add	esp, 10h
test	al, al
jz	short loc_80492A2
mov	eax, 1
jmp	short loc_80492A7

loc_80492A2:
mov	eax, 0

loc_80492A7:
mov	[ebx], al
movzx	eax, [ebp+var_A]
add	eax, 1
mov	[ebp+var_A], al

loc_80492B3:
cmp	[ebp+var_A], 3Fh
jbe	short loc_8049243
movzx	eax, ds:current_pos
mov	ds:selected_pos, al
mov	ds:has_selected, 1
jmp	loc_8049408

loc_80492D1:
movzx	eax, ds:selected_pos
cmp	al, 3Fh
jbe	short loc_80492F5
push	offset __PRETTY_FUNCTION___2764
push	122h
push	offset aProgram_c ; "program.c"
push	offset a0Selected_posS ; "0 <= selected_pos && selected_pos < BOA"...
call	___assert_fail

loc_80492F5:
mov	edx, ds:are_marked
movzx	eax, ds:current_pos
movzx	eax, al
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	loc_80493D2
movzx	eax, ds:current_pos
movzx	edx, al
movzx	eax, ds:selected_pos
movzx	eax, al
sub	esp, 4
push	1
push	edx
push	eax
call	legal_move
add	esp, 10h
movzx	eax, ds:cur_player
test	al, al
setz	al
mov	ds:cur_player, al
sub	esp, 0Ch
push	offset aChangeTurn ; "change turn"
call	_puts
add	esp, 10h
movzx	eax, ds:cur_player
test	al, al
setz	al
movzx	eax, al
sub	esp, 4
push	0
push	0
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jz	short loc_8049399
movzx	eax, ds:cur_player
test	al, al
setz	al
movzx	eax, al
sub	esp, 8
push	eax
push	offset aPlayerDYouAreI ; "Player %d, you are in	check!!!\n"
call	_printf
add	esp, 10h

loc_8049399:
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 4
push	0
push	0
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jz	short loc_80493D2
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 8
push	eax
push	offset aPlayerDYouAreI ; "Player %d, you are in	check!!!\n"
call	_printf
add	esp, 10h

loc_80493D2:
mov	[ebp+var_9], 0
jmp	short loc_80493F1

loc_80493D8:
mov	edx, ds:are_marked
movzx	eax, [ebp+var_9]
add	eax, edx
mov	byte ptr [eax],	0
movzx	eax, [ebp+var_9]
add	eax, 1
mov	[ebp+var_9], al

loc_80493F1:
cmp	[ebp+var_9], 3Fh
jbe	short loc_80493D8
mov	ds:selected_pos, 0FFh
mov	ds:has_selected, 0
jmp	short loc_8049408

loc_8049407:
nop

loc_8049408:
mov	ebx, [ebp+var_4]
leave
retn
process	endp



; Attributes: bp-based frame

public is_in_check
is_in_check proc near

var_24=	byte ptr -24h
var_20=	byte ptr -20h
var_1C=	byte ptr -1Ch
var_E= byte ptr	-0Eh
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
arg_0= dword ptr  8
arg_4= dword ptr  0Ch
arg_8= dword ptr  10h

push	ebp
mov	ebp, esp
sub	esp, 28h
mov	ecx, [ebp+arg_0]
mov	edx, [ebp+arg_4]
mov	eax, [ebp+arg_8]
mov	[ebp+var_1C], cl
mov	[ebp+var_20], dl
mov	[ebp+var_24], al
mov	edx, ds:cells_type
movzx	eax, [ebp+var_24]
add	eax, edx
movzx	eax, byte ptr [eax]
mov	[ebp+var_B], al
mov	edx, ds:cells_side
movzx	eax, [ebp+var_24]
add	eax, edx
movzx	eax, byte ptr [eax]
mov	[ebp+var_A], al
movzx	eax, ds:cur_player
mov	[ebp+var_9], al
cmp	[ebp+var_1C], 0
setz	al
mov	ds:cur_player, al
mov	[ebp+var_C], 0
movzx	edx, [ebp+var_24]
movzx	eax, [ebp+var_20]
sub	esp, 8
push	edx
push	eax
call	actual_move
add	esp, 10h
mov	[ebp+var_E], 0
jmp	short loc_80494AF

loc_804947E:
mov	edx, ds:cells_type
movzx	eax, [ebp+var_E]
add	eax, edx
movzx	eax, byte ptr [eax]
cmp	al, 6
jnz	short loc_80494A5
mov	edx, ds:cells_side
movzx	eax, [ebp+var_E]
add	eax, edx
movzx	eax, byte ptr [eax]
cmp	al, [ebp+var_1C]
jz	short loc_80494B7

loc_80494A5:
movzx	eax, [ebp+var_E]
add	eax, 1
mov	[ebp+var_E], al

loc_80494AF:
cmp	[ebp+var_E], 3Fh
jbe	short loc_804947E
jmp	short loc_80494B8

loc_80494B7:
nop

loc_80494B8:
cmp	[ebp+var_E], 3Fh
ja	short loc_80494EE
mov	[ebp+var_D], 0
jmp	short loc_80494E8

loc_80494C4:
movzx	edx, [ebp+var_E]
movzx	eax, [ebp+var_D]
sub	esp, 4
push	0
push	edx
push	eax
call	legal_move
add	esp, 10h
or	[ebp+var_C], al
movzx	eax, [ebp+var_D]
add	eax, 1
mov	[ebp+var_D], al

loc_80494E8:
cmp	[ebp+var_D], 3Fh
jbe	short loc_80494C4

loc_80494EE:
movzx	edx, [ebp+var_20]
movzx	eax, [ebp+var_24]
sub	esp, 8
push	edx
push	eax
call	actual_move
add	esp, 10h
mov	edx, ds:cells_type
movzx	eax, [ebp+var_24]
add	edx, eax
movzx	eax, [ebp+var_B]
mov	[edx], al
mov	edx, ds:cells_side
movzx	eax, [ebp+var_24]
add	edx, eax
movzx	eax, [ebp+var_A]
mov	[edx], al
movzx	eax, [ebp+var_9]
mov	ds:cur_player, al
movzx	eax, [ebp+var_C]
leave
retn
is_in_check endp



; Attributes: bp-based frame

public legal_move
legal_move proc	near

var_24=	byte ptr -24h
var_20=	byte ptr -20h
var_1C=	byte ptr -1Ch
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_4= dword ptr -4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch
arg_8= dword ptr  10h

push	ebp
mov	ebp, esp
push	ebx
sub	esp, 24h
mov	ecx, [ebp+arg_0]
mov	edx, [ebp+arg_4]
mov	eax, [ebp+arg_8]
mov	[ebp+var_1C], cl
mov	[ebp+var_20], dl
mov	[ebp+var_24], al
movzx	eax, [ebp+var_1C]
sub	esp, 0Ch
push	eax
call	is_own_piece
add	esp, 10h
test	al, al
jnz	short loc_804956D
mov	eax, 0
jmp	loc_8049DE9

loc_804956D:
movzx	eax, [ebp+var_20]
sub	esp, 0Ch
push	eax
call	is_own_piece
add	esp, 10h
test	al, al
jz	short loc_804958B
mov	eax, 0
jmp	loc_8049DE9

loc_804958B:
movzx	eax, [ebp+var_1C]
cmp	al, [ebp+var_20]
jnz	short loc_804959E
mov	eax, 0
jmp	loc_8049DE9

loc_804959E:
cmp	[ebp+var_1C], 3Fh
jbe	short loc_80495AE
mov	eax, 0
jmp	loc_8049DE9

loc_80495AE:
cmp	[ebp+var_20], 3Fh
jbe	short loc_80495BE
mov	eax, 0
jmp	loc_8049DE9

loc_80495BE:
movzx	eax, [ebp+var_1C]
shr	al, 3
mov	[ebp+var_D], al
movzx	eax, [ebp+var_1C]
and	eax, 7
mov	[ebp+var_C], al
movzx	eax, [ebp+var_20]
shr	al, 3
mov	[ebp+var_B], al
movzx	eax, [ebp+var_20]
and	eax, 7
mov	[ebp+var_A], al
mov	edx, ds:cells_type
movzx	eax, [ebp+var_1C]
add	eax, edx
movzx	eax, byte ptr [eax]
movzx	eax, al
cmp	eax, 6		; switch 7 cases
ja	loc_8049D0B	; default
mov	eax, ds:off_804A66C[eax*4]
jmp	eax		; switch jump

loc_804960A:		; case 0x0
mov	eax, 0
jmp	loc_8049DE9

loc_8049614:		; case 0x1
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
jbe	short loc_804963D
mov	eax, 0
jmp	loc_8049DE9

loc_804963D:
movzx	eax, [ebp+var_D]
cmp	al, [ebp+var_B]
jl	short loc_8049659
mov	edx, ds:cells_side
movzx	eax, [ebp+var_1C]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_8049675

loc_8049659:
movzx	eax, [ebp+var_D]
cmp	al, [ebp+var_B]
jg	short loc_804967F
mov	edx, ds:cells_side
movzx	eax, [ebp+var_1C]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_804967F

loc_8049675:
mov	eax, 0
jmp	loc_8049DE9

loc_804967F:
movzx	eax, [ebp+var_C]
cmp	al, [ebp+var_A]
jnz	loc_804977A
movzx	edx, [ebp+var_D]
movzx	eax, [ebp+var_B]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
jnz	short loc_80496CC
mov	edx, ds:cells_type
movzx	eax, [ebp+var_20]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	loc_804982A
mov	eax, 0
jmp	loc_8049DE9

loc_80496CC:
movzx	edx, [ebp+var_D]
movzx	eax, [ebp+var_B]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 2
jnz	loc_8049770
mov	edx, ds:cells_type
movzx	eax, [ebp+var_20]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jnz	short loc_804974B
mov	edx, ds:cells_type
movzx	ecx, [ebp+var_1C]
movzx	eax, [ebp+var_20]
add	eax, ecx
mov	ecx, eax
shr	ecx, 1Fh
add	eax, ecx
sar	eax, 1
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jnz	short loc_804974B
movsx	edx, [ebp+var_D]
mov	ecx, ds:cells_side
movzx	eax, [ebp+var_1C]
add	eax, ecx
movzx	eax, byte ptr [eax]
test	al, al
jnz	short loc_8049742
mov	eax, 1
jmp	short loc_8049747

loc_8049742:
mov	eax, 6

loc_8049747:
cmp	edx, eax
jz	short loc_8049755

loc_804974B:
mov	eax, 0
jmp	loc_8049DE9

loc_8049755:
cmp	[ebp+var_24], 0
jz	loc_804982A
movzx	eax, [ebp+var_C]
add	eax, 8
mov	ds:en_passant_flag, al
jmp	loc_804982A

loc_8049770:
mov	eax, 0
jmp	loc_8049DE9

loc_804977A:
movzx	edx, [ebp+var_D]
movzx	eax, [ebp+var_B]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
jz	short loc_80497A3
mov	eax, 0
jmp	loc_8049DE9

loc_80497A3:
mov	edx, ds:cells_type
movzx	eax, [ebp+var_20]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jnz	short loc_804982A
movsx	edx, [ebp+var_A]
movzx	eax, ds:en_passant_flag
movzx	eax, al
cmp	edx, eax
jnz	short loc_8049820
movsx	edx, [ebp+var_B]
mov	ecx, ds:cells_side
movzx	eax, [ebp+var_1C]
add	eax, ecx
movzx	eax, byte ptr [eax]
test	al, al
jnz	short loc_80497E6
mov	eax, 5
jmp	short loc_80497EB

loc_80497E6:
mov	eax, 2

loc_80497EB:
cmp	edx, eax
jnz	short loc_8049820
cmp	[ebp+var_24], 0
jz	short loc_804982A
mov	ebx, ds:cells_type
movzx	eax, [ebp+var_A]
movzx	edx, al
movzx	eax, [ebp+var_D]
movzx	eax, al
sub	esp, 8
push	edx
push	eax
call	to_pos
add	esp, 10h
movzx	eax, al
add	eax, ebx
mov	byte ptr [eax],	0
jmp	short loc_804982A

loc_8049820:
mov	eax, 0
jmp	loc_8049DE9

loc_804982A:
cmp	[ebp+var_24], 0
jz	loc_8049CF8
movsx	edx, [ebp+var_B]
mov	ecx, ds:cells_side
movzx	eax, [ebp+var_1C]
add	eax, ecx
movzx	eax, byte ptr [eax]
test	al, al
jnz	short loc_8049852
mov	eax, 7
jmp	short loc_8049857

loc_8049852:
mov	eax, 0

loc_8049857:
cmp	edx, eax
jnz	loc_8049CF8
mov	edx, ds:cells_type
movzx	eax, [ebp+var_1C]
lea	ebx, [edx+eax]
call	promote_pawn
mov	[ebx], al
jmp	loc_8049CF8

loc_8049878:		; case 0x2
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
jnz	short loc_80498BA
movzx	edx, [ebp+var_D]
movzx	eax, [ebp+var_B]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 2
jz	loc_8049CFB

loc_80498BA:
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 2
jnz	short loc_80498FC
movzx	edx, [ebp+var_D]
movzx	eax, [ebp+var_B]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
jz	loc_8049CFB

loc_80498FC:
mov	eax, 0
jmp	loc_8049DE9

loc_8049906:		; case 0x3
movzx	edx, [ebp+var_20]
movzx	eax, [ebp+var_1C]
push	1
push	0
push	edx
push	eax
call	is_path_clear
add	esp, 10h
test	al, al
jnz	loc_8049CFE
mov	eax, 0
jmp	loc_8049DE9

loc_804992E:		; case 0x4
movzx	edx, [ebp+var_20]
movzx	eax, [ebp+var_1C]
push	0
push	1
push	edx
push	eax
call	is_path_clear
add	esp, 10h
test	al, al
jnz	short loc_8049952
mov	eax, 0
jmp	loc_8049DE9

loc_8049952:
cmp	[ebp+var_24], 0
jz	loc_8049D01
sub	esp, 8
push	0
push	0
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_1C]
jnz	short loc_804997F
movzx	eax, ds:castle_flag
or	eax, 1
mov	ds:castle_flag,	al

loc_804997F:
sub	esp, 8
push	7
push	0
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_1C]
jnz	short loc_80499A2
movzx	eax, ds:castle_flag
or	eax, 2
mov	ds:castle_flag,	al

loc_80499A2:
sub	esp, 8
push	0
push	7
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_1C]
jnz	short loc_80499C5
movzx	eax, ds:castle_flag
or	eax, 4
mov	ds:castle_flag,	al

loc_80499C5:
sub	esp, 8
push	7
push	7
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_1C]
jnz	loc_8049D01
movzx	eax, ds:castle_flag
or	eax, 8
mov	ds:castle_flag,	al
jmp	loc_8049D01

loc_80499F1:		; case 0x5
movzx	edx, [ebp+var_20]
movzx	eax, [ebp+var_1C]
push	1
push	1
push	edx
push	eax
call	is_path_clear
add	esp, 10h
test	al, al
jnz	loc_8049D04
mov	eax, 0
jmp	loc_8049DE9

loc_8049A19:		; case 0x6
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
ja	short loc_8049A8E
movzx	edx, [ebp+var_D]
movzx	eax, [ebp+var_B]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 1
ja	short loc_8049A8E
cmp	[ebp+var_24], 0
jz	loc_8049D07
movzx	eax, ds:cur_player
movzx	eax, al
add	eax, 4
mov	edx, 1
mov	ecx, eax
shl	edx, cl
mov	eax, edx
mov	edx, eax
movzx	eax, ds:castle_flag
or	eax, edx
mov	ds:castle_flag,	al
jmp	loc_8049D07

loc_8049A8E:
cmp	[ebp+var_C], 4
jnz	short loc_8049AB3
movsx	edx, [ebp+var_D]
movzx	eax, ds:cur_player
test	al, al
jnz	short loc_8049AAA
mov	eax, 0
jmp	short loc_8049AAF

loc_8049AAA:
mov	eax, 7

loc_8049AAF:
cmp	edx, eax
jz	short loc_8049ABD

loc_8049AB3:
mov	eax, 0
jmp	loc_8049DE9

loc_8049ABD:
movzx	eax, ds:castle_flag
movzx	edx, al
movzx	eax, ds:cur_player
movzx	eax, al
add	eax, 4
mov	ecx, eax
sar	edx, cl
mov	eax, edx
and	eax, 1
test	eax, eax
jz	short loc_8049AEB
mov	eax, 0
jmp	loc_8049DE9

loc_8049AEB:
movzx	eax, [ebp+var_D]
cmp	al, [ebp+var_B]
jz	short loc_8049AFE
mov	eax, 0
jmp	loc_8049DE9

loc_8049AFE:
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
cmp	al, 2
jz	short loc_8049B27
mov	eax, 0
jmp	loc_8049DE9

loc_8049B27:
movsx	edx, [ebp+var_A]
movsx	eax, [ebp+var_C]
mov	ebx, edx
sub	ebx, eax
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
movzx	ecx, al
mov	eax, ebx
cdq
idiv	ecx
mov	[ebp+var_9], al
movzx	eax, ds:castle_flag
movzx	edx, al
movzx	eax, ds:cur_player
movzx	eax, al
lea	ecx, [eax+eax]
cmp	[ebp+var_9], 1
setz	al
movzx	eax, al
add	eax, ecx
mov	ecx, eax
sar	edx, cl
mov	eax, edx
and	eax, 1
test	eax, eax
jz	short loc_8049B93
mov	eax, 0
jmp	loc_8049DE9

loc_8049B93:
movzx	eax, ds:cur_player
shl	eax, 3
lea	edx, ds:0[eax*8]
sub	edx, eax
mov	eax, edx
cmp	[ebp+var_9], 1
jnz	short loc_8049BB5
mov	edx, 7
jmp	short loc_8049BBA

loc_8049BB5:
mov	edx, 0

loc_8049BBA:
add	eax, edx
movzx	edx, al
movzx	eax, [ebp+var_1C]
push	0
push	1
push	edx
push	eax
call	is_path_clear
add	esp, 10h
test	al, al
jnz	short loc_8049BDF
mov	eax, 0
jmp	loc_8049DE9

loc_8049BDF:
movzx	ecx, [ebp+var_1C]
movzx	edx, [ebp+var_1C]
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 4
push	ecx
push	edx
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jz	short loc_8049C0D
mov	eax, 0
jmp	loc_8049DE9

loc_8049C0D:
movzx	edx, [ebp+var_1C]
movzx	eax, [ebp+var_9]
add	eax, edx
movzx	ecx, al
movzx	edx, [ebp+var_1C]
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 4
push	ecx
push	edx
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jz	short loc_8049C44
mov	eax, 0
jmp	loc_8049DE9

loc_8049C44:
movzx	eax, [ebp+var_9]
lea	edx, [eax+eax]
movzx	eax, [ebp+var_1C]
add	eax, edx
movzx	ecx, al
movzx	edx, [ebp+var_1C]
movzx	eax, ds:cur_player
movzx	eax, al
sub	esp, 4
push	ecx
push	edx
push	eax
call	is_in_check
add	esp, 10h
test	al, al
jz	short loc_8049C7E
mov	eax, 0
jmp	loc_8049DE9

loc_8049C7E:
cmp	[ebp+var_24], 0
jz	loc_8049D0A
movzx	edx, [ebp+var_1C]
movzx	eax, [ebp+var_9]
add	eax, edx
movzx	edx, al
movzx	eax, ds:cur_player
shl	eax, 3
lea	ecx, ds:0[eax*8]
sub	ecx, eax
mov	eax, ecx
cmp	[ebp+var_9], 1
jnz	short loc_8049CB7
mov	ecx, 7
jmp	short loc_8049CBC

loc_8049CB7:
mov	ecx, 0

loc_8049CBC:
add	eax, ecx
movzx	eax, al
sub	esp, 8
push	edx
push	eax
call	actual_move
add	esp, 10h
movzx	eax, ds:cur_player
movzx	eax, al
add	eax, 4
mov	edx, 1
mov	ecx, eax
shl	edx, cl
mov	eax, edx
mov	edx, eax
movzx	eax, ds:castle_flag
or	eax, edx
mov	ds:castle_flag,	al
jmp	short loc_8049D0A

loc_8049CF8:
nop
jmp	short loc_8049D0B ; default

loc_8049CFB:
nop
jmp	short loc_8049D0B ; default

loc_8049CFE:
nop
jmp	short loc_8049D0B ; default

loc_8049D01:
nop
jmp	short loc_8049D0B ; default

loc_8049D04:
nop
jmp	short loc_8049D0B ; default

loc_8049D07:
nop
jmp	short loc_8049D0B ; default

loc_8049D0A:
nop

loc_8049D0B:		; default
cmp	[ebp+var_24], 0
jz	loc_8049DE4
movzx	edx, [ebp+var_20]
movzx	eax, [ebp+var_1C]
sub	esp, 8
push	edx
push	eax
call	actual_move
add	esp, 10h
movzx	eax, ds:en_passant_flag
cmp	al, 0FFh
jz	short loc_8049D51
movzx	eax, ds:en_passant_flag
cmp	al, 7
jbe	short loc_8049D51
movzx	eax, ds:en_passant_flag
sub	eax, 8
mov	ds:en_passant_flag, al
jmp	short loc_8049D58

loc_8049D51:
mov	ds:en_passant_flag, 0FFh

loc_8049D58:
sub	esp, 8
push	0
push	0
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_20]
jnz	short loc_8049D7B
movzx	eax, ds:castle_flag
or	eax, 1
mov	ds:castle_flag,	al

loc_8049D7B:
sub	esp, 8
push	7
push	0
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_20]
jnz	short loc_8049D9E
movzx	eax, ds:castle_flag
or	eax, 2
mov	ds:castle_flag,	al

loc_8049D9E:
sub	esp, 8
push	0
push	7
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_20]
jnz	short loc_8049DC1
movzx	eax, ds:castle_flag
or	eax, 4
mov	ds:castle_flag,	al

loc_8049DC1:
sub	esp, 8
push	7
push	7
call	to_pos
add	esp, 10h
cmp	al, [ebp+var_20]
jnz	short loc_8049DE4
movzx	eax, ds:castle_flag
or	eax, 8
mov	ds:castle_flag,	al

loc_8049DE4:
mov	eax, 1

loc_8049DE9:
mov	ebx, [ebp+var_4]
leave
retn
legal_move endp



; Attributes: bp-based frame

public is_own_piece
is_own_piece proc near

var_4= byte ptr	-4
arg_0= dword ptr  8

push	ebp
mov	ebp, esp
sub	esp, 4
mov	eax, [ebp+arg_0]
mov	[ebp+var_4], al
mov	edx, ds:cells_type
movzx	eax, [ebp+var_4]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_8049E2E
mov	edx, ds:cells_side
movzx	eax, [ebp+var_4]
add	eax, edx
movzx	edx, byte ptr [eax]
movzx	eax, ds:cur_player
cmp	dl, al
jnz	short loc_8049E2E
mov	eax, 1
jmp	short locret_8049E33

loc_8049E2E:
mov	eax, 0

locret_8049E33:
leave
retn
is_own_piece endp



; Attributes: bp-based frame

public is_path_clear
is_path_clear proc near

var_28=	byte ptr -28h
var_24=	byte ptr -24h
var_20=	byte ptr -20h
var_1C=	byte ptr -1Ch
var_13=	byte ptr -13h
var_12=	byte ptr -12h
var_11=	byte ptr -11h
var_10=	byte ptr -10h
var_F= byte ptr	-0Fh
var_E= byte ptr	-0Eh
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_4= dword ptr -4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch
arg_8= dword ptr  10h
arg_C= dword ptr  14h

push	ebp
mov	ebp, esp
push	ebx
sub	esp, 24h
mov	ebx, [ebp+arg_0]
mov	ecx, [ebp+arg_4]
mov	edx, [ebp+arg_8]
mov	eax, [ebp+arg_C]
mov	[ebp+var_1C], bl
mov	[ebp+var_20], cl
mov	[ebp+var_24], dl
mov	[ebp+var_28], al
cmp	[ebp+var_1C], 3Fh
jbe	short loc_8049E73
push	offset __PRETTY_FUNCTION___2817	; "is_path_clear"
push	1D5h
push	offset aProgram_c ; "program.c"
push	offset a0Src_posSrc_po ; "0 <= src_pos && src_pos < BOARD_SIZE"
call	___assert_fail

loc_8049E73:
cmp	[ebp+var_20], 3Fh
jbe	short loc_8049E92
push	offset __PRETTY_FUNCTION___2817	; "is_path_clear"
push	1D6h
push	offset aProgram_c ; "program.c"
push	offset a0Des_posDes_po ; "0 <= des_pos && des_pos < BOARD_SIZE"
call	___assert_fail

loc_8049E92:
movzx	eax, [ebp+var_1C]
shr	al, 3
mov	[ebp+var_12], al
movzx	eax, [ebp+var_1C]
and	eax, 7
mov	[ebp+var_11], al
movzx	eax, [ebp+var_20]
shr	al, 3
mov	[ebp+var_10], al
movzx	eax, [ebp+var_20]
and	eax, 7
mov	[ebp+var_F], al
movzx	edx, [ebp+var_12]
movzx	eax, [ebp+var_10]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
mov	[ebp+var_E], al
movzx	edx, [ebp+var_11]
movzx	eax, [ebp+var_F]
sub	edx, eax
mov	eax, edx
movsx	eax, al
sub	esp, 0Ch
push	eax
call	absolute
add	esp, 10h
mov	[ebp+var_D], al
cmp	[ebp+var_E], 0
jz	short loc_8049F15
cmp	[ebp+var_D], 0
jz	short loc_8049F15
movzx	eax, [ebp+var_E]
cmp	al, [ebp+var_D]
jz	short loc_8049F15
mov	eax, 0
jmp	loc_804A038

loc_8049F15:
movzx	eax, [ebp+var_1C]
cmp	al, [ebp+var_20]
jnz	short loc_8049F28
mov	eax, 1
jmp	loc_804A038

loc_8049F28:
movzx	eax, [ebp+var_D]
movzx	edx, [ebp+var_E]
cmp	[ebp+var_E], al
cmovge	eax, edx
mov	[ebp+var_C], al
cmp	[ebp+var_E], 0
jz	short loc_8049F54
movsx	edx, [ebp+var_10]
movsx	eax, [ebp+var_12]
sub	edx, eax
mov	eax, edx
movsx	ebx, [ebp+var_C]
cdq
idiv	ebx
jmp	short loc_8049F59

loc_8049F54:
mov	eax, 0

loc_8049F59:
mov	[ebp+var_B], al
cmp	[ebp+var_D], 0
jz	short loc_8049F77
movsx	edx, [ebp+var_F]
movsx	eax, [ebp+var_11]
sub	edx, eax
mov	eax, edx
movsx	ebx, [ebp+var_C]
cdq
idiv	ebx
jmp	short loc_8049F7C

loc_8049F77:
mov	eax, 0

loc_8049F7C:
mov	[ebp+var_A], al
cmp	[ebp+var_B], 0
setnz	dl
cmp	[ebp+var_A], 0
setnz	al
and	eax, edx
test	al, al
jz	short loc_8049FA3
cmp	[ebp+var_28], 0
jnz	short loc_8049FA3
mov	eax, 0
jmp	loc_804A038

loc_8049FA3:
cmp	[ebp+var_B], 0
setnz	dl
cmp	[ebp+var_A], 0
setnz	al
xor	eax, edx
test	al, al
jz	short loc_8049FC4
cmp	[ebp+var_24], 0
jnz	short loc_8049FC4
mov	eax, 0
jmp	short loc_804A038

loc_8049FC4:
mov	[ebp+var_13], 1
jmp	short loc_804A02A

loc_8049FCA:
movzx	eax, [ebp+var_A]
movzx	edx, [ebp+var_13]
imul	eax, edx
mov	edx, eax
movzx	eax, [ebp+var_11]
add	eax, edx
movzx	edx, al
movzx	eax, [ebp+var_B]
movzx	ecx, [ebp+var_13]
imul	eax, ecx
mov	ecx, eax
movzx	eax, [ebp+var_12]
add	eax, ecx
movzx	eax, al
sub	esp, 8
push	edx
push	eax
call	to_pos
add	esp, 10h
mov	[ebp+var_9], al
mov	edx, ds:cells_type
movsx	eax, [ebp+var_9]
add	eax, edx
movzx	eax, byte ptr [eax]
test	al, al
jz	short loc_804A020
mov	eax, 0
jmp	short loc_804A038

loc_804A020:
movzx	eax, [ebp+var_13]
add	eax, 1
mov	[ebp+var_13], al

loc_804A02A:
movzx	eax, [ebp+var_13]
cmp	al, [ebp+var_C]
jl	short loc_8049FCA
mov	eax, 1

loc_804A038:
mov	ebx, [ebp+var_4]
leave
retn
is_path_clear endp



; Attributes: bp-based frame

public actual_move
actual_move proc near

var_10=	byte ptr -10h
var_C= byte ptr	-0Ch
arg_0= dword ptr  8
arg_4= dword ptr  0Ch

push	ebp
mov	ebp, esp
sub	esp, 18h
mov	edx, [ebp+arg_0]
mov	eax, [ebp+arg_4]
mov	[ebp+var_C], dl
mov	[ebp+var_10], al
cmp	[ebp+var_C], 3Fh
jbe	short loc_804A06E
push	offset __PRETTY_FUNCTION___2836	; "actual_move"
push	1F8h
push	offset aProgram_c ; "program.c"
push	offset a0Src_posSrc_po ; "0 <= src_pos && src_pos < BOARD_SIZE"
call	___assert_fail

loc_804A06E:
cmp	[ebp+var_10], 3Fh
jbe	short loc_804A08D
push	offset __PRETTY_FUNCTION___2836	; "actual_move"
push	1F9h
push	offset aProgram_c ; "program.c"
push	offset a0Des_posDes_po ; "0 <= des_pos && des_pos < BOARD_SIZE"
call	___assert_fail

loc_804A08D:
movzx	eax, [ebp+var_C]
cmp	al, [ebp+var_10]
jz	short loc_804A0E1
mov	edx, ds:cells_type
movzx	eax, [ebp+var_10]
add	edx, eax
mov	ecx, ds:cells_type
movzx	eax, [ebp+var_C]
add	eax, ecx
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	edx, ds:cells_side
movzx	eax, [ebp+var_10]
add	edx, eax
mov	ecx, ds:cells_side
movzx	eax, [ebp+var_C]
add	eax, ecx
movzx	eax, byte ptr [eax]
mov	[edx], al
mov	edx, ds:cells_type
movzx	eax, [ebp+var_C]
add	eax, edx
mov	byte ptr [eax],	0
jmp	short locret_804A0E2

loc_804A0E1:
nop

locret_804A0E2:
leave
retn
actual_move endp



; Attributes: bp-based frame

public to_pos
to_pos proc near

var_8= byte ptr	-8
var_4= byte ptr	-4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch

push	ebp
mov	ebp, esp
sub	esp, 8
mov	edx, [ebp+arg_0]
mov	eax, [ebp+arg_4]
mov	[ebp+var_4], dl
mov	[ebp+var_8], al
movzx	eax, [ebp+var_4]
lea	edx, ds:0[eax*8]
movzx	eax, [ebp+var_8]
add	eax, edx
leave
retn
to_pos endp



; Attributes: bp-based frame

public absolute
absolute proc near

var_4= byte ptr	-4
arg_0= dword ptr  8

push	ebp
mov	ebp, esp
sub	esp, 4
mov	eax, [ebp+arg_0]
mov	[ebp+var_4], al
cmp	[ebp+var_4], 0
js	short loc_804A122
mov	eax, 1
jmp	short loc_804A127

loc_804A122:
mov	eax, 0FFFFFFFFh

loc_804A127:
movzx	edx, [ebp+var_4]
imul	eax, edx
leave
retn
absolute endp




public __libc_csu_init
__libc_csu_init	proc near

arg_0= dword ptr  14h
arg_4= dword ptr  18h
arg_8= dword ptr  1Ch

push	ebp
push	edi
push	esi
push	ebx
call	__x86_get_pc_thunk_bx
add	ebx, 1EC7h
sub	esp, 0Ch
mov	ebp, [esp+0Ch+arg_0]
lea	esi, [ebx-0F4h]
call	_init_proc
lea	eax, [ebx-0F8h]
sub	esi, eax
sar	esi, 2
test	esi, esi
jz	short loc_804A185
xor	edi, edi
lea	esi, [esi+0]

loc_804A168:
sub	esp, 4
push	[esp+10h+arg_8]
push	[esp+14h+arg_4]
push	ebp
call	dword ptr [ebx+edi*4-0F8h]
add	edi, 1
add	esp, 10h
cmp	edi, esi
jnz	short loc_804A168

loc_804A185:
add	esp, 0Ch
pop	ebx
pop	esi
pop	edi
pop	ebp
retn
__libc_csu_init	endp

align 10h



public __libc_csu_fini
__libc_csu_fini	proc near
rep retn
__libc_csu_fini	endp

_text ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use32
assume cs:_fini
;org 804A194h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _term_proc
_term_proc proc	near
push	ebx		; _fini
sub	esp, 8
call	__x86_get_pc_thunk_bx
add	ebx, 1E63h
add	esp, 8
pop	ebx
retn
_term_proc endp

_fini ends


; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata	segment	para public 'CONST' use32
assume cs:_rodata
;org 804A1C0h
public _fp_hw
_fp_hw dd 3
public _IO_stdin_used
_IO_stdin_used dd 20001h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
aTrue db 'TRUE',0
aFalse db 'FALSE',0
; char aCur_playerS[]
aCur_playerS db	'cur_player   == %s',0Ah,0
; char aHas_selectedS[]
aHas_selectedS db 'has_selected == %s',0Ah,0
; char aIs_clickedS[]
aIs_clickedS db	'is_clicked   == %s',0Ah,0
; char aSelected_posDD[]
aSelected_posDD	db 'selected_pos == (%d,%d);',0Ah,0
; char aCurrent_posDD[]
aCurrent_posDD db 'current_pos  == (%d,%d);',0Ah,0
; char aEn_paasant_fla[]
aEn_paasant_fla	db 'en_paasant_flag  == %d;',0Ah,0
; char aCastle_flagD[]
aCastle_flagD db 'castle_flag      == %d;',0Ah,0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
asc_804A2A0 db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
a@@@@@ db '  @@@@@  ',0
a@@@@@_0 db '  @@@@@  ',0
a@@@@@_1 db '  @@@@@  ',0
a@@@@ db ' @@   @@ ',0
a@@@@_0	db ' @@   @@ ',0
a@@ db '     @@  ',0
a@@@@@@@ db ' @@@@@@@ ',0
a@ db '    @    ',0
a@@@@_1	db '  @@ @@  ',0
a@@@ db	'   @@@   ',0
a@_0 db	'    @    ',0
a@@@@@@@_0 db ' @@@@@@@ ',0
a@@@@@@@_1 db '@@ @@@ @@',0
a@@@@@@@@@ db '@@@@@@@@@',0
a@@@_0 db '   @@@   ',0
a@@@_1 db '   @@@   ',0
a@@@@@@@_2 db ' @@@@@@@ ',0
a@@@@@@@_3 db '@@ @@@ @@',0
a@@@@@@@_4 db '@@ @@@ @@',0
a@@@@@@@_5 db '@@ @@@ @@',0
a@@@@@@@_6 db ' @@@@@@@ ',0
a@@@@@@@_7 db ' @@@@@@@ ',0
a@@@_2 db '@   @   @',0
a@@@@@@@_8 db '@ @@@@@ @',0
a@@@_3 db '@   @   @',0
a@@@@@@@_9 db ' @@@@@@@ ',0
a@@@@@@@_10 db ' @@@@@@@ ',0
align 10h
; char aGetInputAswdFo[]
aGetInputAswdFo	db 'Get input (aswd for direction, f fo'
db 'r click) : ',0
aS db '%s',0
; void aCannotRecognis
aCannotRecognis	db 'cannot recognise the input',0
align 10h
off_804A450 dd offset loc_8048C6E ; jump table for switch statement
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048C8B
dd offset loc_8048CEB
dd offset loc_8048CE2
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CA8
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CC5
; char aTheCurrentPawn[]
aTheCurrentPawn	db 'The current pawn is promoting... ',0
align 10h
; char aWhichTypeThatY[]
aWhichTypeThatY	db 'Which type that you want your pawn '
db 'to be... ',0
align 10h
; char aAKnightSBishop[]
aAKnightSBishop	db 'a(knight) s(bishop) d(rook) w(queen'
db ') : ',0
; char asc_804A528[]
asc_804A528 db 0Ah,0
; char asc_804A52A[]
asc_804A52A db '*****************************',0
; char aGameOverPlayer[]
aGameOverPlayer	db '* Game Over Player %c win. *',0Ah,0
; char asc_804A566[]
asc_804A566 db 0Ah
db 0Ah
db 0Ah
db 0Ah,0
; char asc_804A56B[]
asc_804A56B db '***********************',0
; char aGameOverStalem[]
aGameOverStalem	db '* Game Over Stalemate *',0
aProgram_c db 'program.c',0
aCells_typeNull	db 'cells_type != NULL',0
aAre_markedNull	db 'are_marked != NULL',0
aCells_sideNull	db 'cells_side != NULL',0
align 10h
a0Current_posCu	db '0 <= current_pos && current_pos < B'
db 'OARD_SIZE',0
align 10h
a0Selected_posS	db '0 <= selected_pos && selected_pos <'
db ' BOARD_SIZE',0
; char aChangeTurn[]
aChangeTurn db 'change turn',0
align 4
; char aPlayerDYouAreI[]
aPlayerDYouAreI	db 'Player %d, you are in check!!!',0Ah,0
off_804A66C dd offset loc_804960A ; jump table for switch statement
dd offset loc_8049614
dd offset loc_8049878
dd offset loc_8049906
dd offset loc_804992E
dd offset loc_80499F1
dd offset loc_8049A19
a0Src_posSrc_po	db '0 <= src_pos && src_pos < BOARD_SIZ'
db 'E',0
align 10h
a0Des_posDes_po	db '0 <= des_pos && des_pos < BOARD_SIZ'
db 'E',0
align 4
__PRETTY_FUNCTION___2748 db 'initialise',0
align 4
__PRETTY_FUNCTION___2764 dq 737365636F7270h
__PRETTY_FUNCTION___2817 db 'is_path_clear',0
align 4
__PRETTY_FUNCTION___2836 db 'actual_move',0
_rodata	ends


; Segment type:	Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use32
assume cs:_eh_frame_hdr
;org 804A708h
__GNU_EH_FRAME_HDR db	 1
db  1Bh
db    3
db  3Bh	; ;
db  98h	; 
db    0
db    0
db    0
db  12h
db    0
db    0
db    0
db  48h	; H
db 0DDh	; 
db 0FFh
db 0FFh
db 0B4h	; ด
db    0
db    0
db    0
db    3
db 0DFh	; ฿
db 0FFh
db 0FFh
db 0D8h	; ุ
db    0
db    0
db    0
db  5Bh	; [
db 0DFh	; ฿
db 0FFh
db 0FFh
db 0FCh	; 
db    0
db    0
db    0
db 0F4h	; ๔
db 0E4h	; ไ
db 0FFh
db 0FFh
db  2Ch	; ,
db    1
db    0
db    0
db  2Fh	; /
db 0E6h	; ๆ
db 0FFh
db 0FFh
db  4Ch	; L
db    1
db    0
db    0
db 0F3h	; ๓
db 0E6h	; ๆ
db 0FFh
db 0FFh
db  6Ch	; l
db    1
db    0
db    0
db 0E6h	; ๆ
db 0E7h	; ็
db 0FFh
db 0FFh
db  8Ch	; 
db    1
db    0
db    0
db    1
db 0EAh	; ๊
db 0FFh
db 0FFh
db 0ACh	; ฌ
db    1
db    0
db    0
db 0DDh	; 
db 0EAh	; ๊
db 0FFh
db 0FFh
db 0CCh	; ฬ
db    1
db    0
db    0
db    5
db 0EDh	; ํ
db 0FFh
db 0FFh
db 0F0h	; ๐
db    1
db    0
db    0
db  2Eh	; .
db 0EEh	; ๎
db 0FFh
db 0FFh
db  10h
db    2
db    0
db    0
db 0E6h	; ๆ
db 0F6h	; ๖
db 0FFh
db 0FFh
db  34h	; 4
db    2
db    0
db    0
db  2Dh	; -
db 0F7h	; ๗
db 0FFh
db 0FFh
db  54h	; T
db    2
db    0
db    0
db  35h	; 5
db 0F9h	; ๙
db 0FFh
db 0FFh
db  78h	; x
db    2
db    0
db    0
db 0DCh	; 
db 0F9h	; ๙
db 0FFh
db 0FFh
db  98h	; 
db    2
db    0
db    0
db    1
db 0FAh	; ๚
db 0FFh
db 0FFh
db 0B8h	; ธ
db    2
db    0
db    0
db  28h	; (
db 0FAh	; ๚
db 0FFh
db 0FFh
db 0D8h	; ุ
db    2
db    0
db    0
db  88h	; 
db 0FAh	; ๚
db 0FFh
db 0FFh
db  24h	; $
db    3
db    0
db    0
_eh_frame_hdr ends


; Segment type:	Pure data
; Segment permissions: Read
_eh_frame segment dword	public 'CONST' use32
assume cs:_eh_frame
;org 804A7A4h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah	; z
db  52h	; R
db    0
db    1
db  7Ch	; |
db    8
db    1
db  1Bh
db  0Ch
db    4
db    4
db  88h	; 
db    1
db    0
db    0
db  20h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  8Ch	; 
db 0DCh	; 
db 0FFh
db 0FFh
db 0B0h	; ฐ
db    0
db    0
db    0
db    0
db  0Eh
db    8
db  46h	; F
db  0Eh
db  0Ch
db  4Ah	; J
db  0Fh
db  0Bh
db  74h	; t
db    4
db  78h	; x
db    0
db  3Fh	; ?
db  1Ah
db  3Bh	; ;
db  2Ah	; *
db  32h	; 2
db  24h	; $
db  22h	; "
db  20h
db    0
db    0
db    0
db  40h	; @
db    0
db    0
db    0
db  23h	; #
db 0DEh	; 
db 0FFh
db 0FFh
db  58h	; X
db    0
db    0
db    0
db    0
db  44h	; D
db  0Ch
db    1
db    0
db  47h	; G
db  10h
db    5
db    2
db  75h	; u
db    0
db  43h	; C
db  0Fh
db    3
db  75h	; u
db  7Ch	; |
db    6
db    0
db    0
db    0
db  2Ch	; ,
db    0
db    0
db    0
db  64h	; d
db    0
db    0
db    0
db  57h	; W
db 0DEh	; 
db 0FFh
db 0FFh
db  99h	; 
db    5
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db  49h	; I
db  87h	; 
db    3
db  86h	; 
db    4
db  83h	; 
db    5
db    3
db  89h	; 
db    5
db 0C3h	; ร
db  41h	; A
db 0C6h	; ฦ
db  41h	; A
db 0C7h	; ว
db  41h	; A
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  94h	; 
db    0
db    0
db    0
db 0C0h	; ภ
db 0E3h	; ใ
db 0FFh
db 0FFh
db  3Bh	; ;
db    1
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    3
db  37h	; 7
db    1
db 0C5h	; ล
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db 0B4h	; ด
db    0
db    0
db    0
db 0DBh	; 
db 0E4h	; ไ
db 0FFh
db 0FFh
db 0C4h	; ฤ
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0C0h	; ภ
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db  1Ch
db    0
db    0
db    0
db 0D4h	; ิ
db    0
db    0
db    0
db  7Fh	; 
db 0E5h	; ๅ
db 0FFh
db 0FFh
db 0F3h	; ๓
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0EFh	; ๏
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db  1Ch
db    0
db    0
db    0
db 0F4h	; ๔
db    0
db    0
db    0
db  52h	; R
db 0E6h	; ๆ
db 0FFh
db 0FFh
db  1Bh
db    2
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    3
db  17h
db    2
db 0C5h	; ล
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db  14h
db    1
db    0
db    0
db  4Dh	; M
db 0E8h	; ่
db 0FFh
db 0FFh
db 0DCh	; 
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0D8h	; ุ
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db  20h
db    0
db    0
db    0
db  34h	; 4
db    1
db    0
db    0
db    9
db 0E9h	; ้
db 0FFh
db 0FFh
db  28h	; (
db    2
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db  44h	; D
db  83h	; 
db    3
db    3
db  20h
db    2
db 0C5h	; ล
db 0C3h	; ร
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db  58h	; X
db    1
db    0
db    0
db  0Dh
db 0EBh	; ๋
db 0FFh
db 0FFh
db  29h	; )
db    1
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    3
db  25h	; %
db    1
db 0C5h	; ล
db  0Ch
db    4
db    4
db  20h
db    0
db    0
db    0
db  78h	; x
db    1
db    0
db    0
db  16h
db 0ECh	; ์
db 0FFh
db 0FFh
db 0B8h	; ธ
db    8
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db  44h	; D
db  83h	; 
db    3
db    3
db 0B0h	; ฐ
db    8
db 0C5h	; ล
db 0C3h	; ร
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db  9Ch	; 
db    1
db    0
db    0
db 0AAh	; ช
db 0F4h	; ๔
db 0FFh
db 0FFh
db  47h	; G
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    2
db  43h	; C
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db  20h
db    0
db    0
db    0
db 0BCh	; ผ
db    1
db    0
db    0
db 0D1h	; ั
db 0F4h	; ๔
db 0FFh
db 0FFh
db    8
db    2
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db  44h	; D
db  83h	; 
db    3
db    3
db    0
db    2
db 0C5h	; ล
db 0C3h	; ร
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db 0E0h	; เ
db    1
db    0
db    0
db 0B5h	; ต
db 0F6h	; ๖
db 0FFh
db 0FFh
db 0A7h	; ง
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0A3h	; ฃ
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db  1Ch
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db  3Ch	; <
db 0F7h	; ๗
db 0FFh
db 0FFh
db  25h	; %
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db  61h	; a
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  20h
db    2
db    0
db    0
db  41h	; A
db 0F7h	; ๗
db 0FFh
db 0FFh
db  27h	; '
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  42h	; B
db  0Dh
db    5
db  63h	; c
db 0C5h	; ล
db  0Ch
db    4
db    4
db    0
db    0
db  48h	; H
db    0
db    0
db    0
db  40h	; @
db    2
db    0
db    0
db  48h	; H
db 0F7h	; ๗
db 0FFh
db 0FFh
db  5Dh	; ]
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; 
db    2
db  41h	; A
db  0Eh
db  0Ch
db  87h	; 
db    3
db  41h	; A
db  0Eh
db  10h
db  86h	; 
db    4
db  41h	; A
db  0Eh
db  14h
db  83h	; 
db    5
db  4Eh	; N
db  0Eh
db  20h
db  69h	; i
db  0Eh
db  24h	; $
db  44h	; D
db  0Eh
db  28h	; (
db  44h	; D
db  0Eh
db  2Ch	; ,
db  41h	; A
db  0Eh
db  30h	; 0
db  4Dh	; M
db  0Eh
db  20h
db  47h	; G
db  0Eh
db  14h
db  41h	; A
db 0C3h	; ร
db  0Eh
db  10h
db  41h	; A
db 0C6h	; ฦ
db  0Eh
db  0Ch
db  41h	; A
db 0C7h	; ว
db  0Eh
db    8
db  41h	; A
db 0C5h	; ล
db  0Eh
db    4
db    0
db    0
db  10h
db    0
db    0
db    0
db  8Ch	; 
db    2
db    0
db    0
db  5Ch	; \
db 0F7h	; ๗
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
__FRAME_END__ db    0
db    0
db    0
db    0
_eh_frame ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_jcr segment dword public 'DATA' use32
assume cs:_jcr
;org 804BF10h
__JCR_LIST__ db	   0
db    0
db    0
db    0
_jcr ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_got segment dword public 'DATA' use32
assume cs:_got
;org 804BFFCh
off_804BFFC dd offset __imp___gmon_start__
_got ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_got_plt segment dword public 'DATA' use32
assume cs:_got_plt
;org 804C000h
_GLOBAL_OFFSET_TABLE_ db    ? ;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
off_804C00C dd offset printf
off_804C010 dd offset __stack_chk_fail
off_804C014 dd offset fwrite
off_804C018 dd offset malloc
off_804C01C dd offset puts
off_804C020 dd offset __libc_start_main
off_804C024 dd offset memset
off_804C028 dd offset putchar
off_804C02C dd offset __isoc99_scanf
off_804C030 dd offset __assert_fail
_got_plt ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_data segment dword public 'DATA' use32
assume cs:_data
;org 804C034h
public data_start ; weak
data_start db	 0	; Alternative name is '__data_start'
db    0
db    0
db    0
public __dso_handle
__dso_handle db	   0
db    0
db    0
db    0
_data ends


; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss segment para public 'BSS' use32
assume cs:_bss
;org 804C040h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
public stderr@@GLIBC_2_0
; FILE *stderr
stderr@@GLIBC_2_0 dd ?	; Alternative name is 'stderr'
			; Copy of shared data
completed_7200 db ?
align 4
public cells_type
; void *cells_type
cells_type dd ?
public are_marked
; void *are_marked
are_marked dd ?
public current_pos
current_pos db ?
public castle_flag
castle_flag db ?
public has_selected
has_selected db	?
public cur_player
cur_player db ?
public en_passant_flag
en_passant_flag	db ?
public selected_pos
selected_pos db	?
public is_clicked
is_clicked db ?
align 4
public cells_side
; void *cells_side
cells_side dd ?
_bss ends


; Segment type:	Externs
; extern
extrn printf@@GLIBC_2_0:near
extrn __stack_chk_fail@@GLIBC_2_4:near
extrn fwrite@@GLIBC_2_0:near
extrn malloc@@GLIBC_2_0:near
extrn puts@@GLIBC_2_0:near
extrn __libc_start_main@@GLIBC_2_0:near
extrn memset@@GLIBC_2_0:near
extrn putchar@@GLIBC_2_0:near
extrn __isoc99_scanf@@GLIBC_2_7:near
extrn __assert_fail@@GLIBC_2_0:near
; int printf(const char	*,...)
extrn printf:near
extrn __stack_chk_fail:near
; size_t fwrite(const void *,size_t size,size_t	n,FILE *)
extrn fwrite:near
; void *malloc(size_t size)
extrn malloc:near
; int puts(const char *)
extrn puts:near
extrn __libc_start_main:near
; void *memset(void *,int,size_t)
extrn memset:near
; int putchar(int)
extrn putchar:near
extrn __isoc99_scanf:near
extrn __assert_fail:near
extrn _ITM_deregisterTMCloneTable ; weak
extrn __imp___gmon_start__ ; weak
extrn _Jv_RegisterClasses ; weak
extrn _ITM_registerTMCloneTable	; weak


end _start
