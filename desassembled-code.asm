

;
; �������������������������������������������������������������������������ͻ
; �	This file is generated by The Interactive Disassembler (IDA)	    �
; �	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    �
; �			 Licensed to: Freeware version			    �
; �������������������������������������������������������������������������ͼ
;
; Input	MD5   :	5255D2DE1B5B493219667BB79B0861EB

; File Name   :	F:\program
; Format      :	ELF (Executable)
; Interpreter '/lib/ld-linux.so.2'
; Needed Library 'libc.so.6'
;
; Source File :	'crtstuff.c'
; Source File :	'program.c'
; Source File :	'crtstuff.c'

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type:	Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use32
assume cs:_init
;org 8048424h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _init_proc
_init_proc proc	near
push	ebx    ; Empilha valor EBX - _init
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
call	__x86_get_pc_thunk_bx				; Faz uma chamada para a subrotina "__x86_get_pc_thunk_bx"
add	ebx, 3BD3h
mov	eax, [ebx-4]
test	eax, eax							; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8048442						; Faz um salto curto (para um local próximo) até a subrotina "loc_8048442" se a zero flag estiver setada. (ZF = 1)
call	__gmon_start__						; Faz uma chamada para a subrotina "__gmon_start__"

loc_8048442:
add	esp, 8
pop	ebx   ; Desempilha EBX
retn
_init_proc endp

_init ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use32
assume cs:_plt
;org 8048450h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
dd 4 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _printf. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___stack_chk_fail. PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _fwrite. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _malloc. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS	KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _memset. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION _putchar.	PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___isoc99_scanf. PRESS KEYPAD "+"	TO EXPAND]
dw ?
dd 2 dup(?)
; [00000006 BYTES: COLLAPSED FUNCTION ___assert_fail. PRESS KEYPAD "+" TO EXPAND]
dw ?
dd 2 dup(?)
_plt ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
; Segment alignment 'qword' can not be represented in assembly
_plt_got segment para public 'CODE' use32
assume cs:_plt_got
;org 8048500h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION __gmon_start__. PRESS KEYPAD "+" TO EXPAND]
align 4
_plt_got ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use32
assume cs:_text
;org 8048510h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _start
_start proc near
xor	ebp, ebp    											; Aplica OU exclusivo bit-a-bit entre EBP e EBP, armaena resultado em EBP
pop	esi   													; Desempilha ESI
mov	ecx, esp    											; Copia valor do registrador ESP para ECX
and	esp, 0FFFFFFF0h   										; Realiza operação booleana "AND" bit-a-bit e armazena valor lógico em ESP
push	eax    												; Empilha valor de EAX
push	esp    												; Empilha valor de ESP
push	edx    												; Empilha valor de EDX
push	offset __libc_csu_fini
push	offset __libc_csu_init
push	ecx    												; Empilha valor de ECX
push	esi    												; Empilha ESI
push	offset main
call	___libc_start_main									; Faz uma chamada para a subrotina "___libc_start_main"
hlt
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
db	66h
nop
_start endp




public __x86_get_pc_thunk_bx
__x86_get_pc_thunk_bx proc near
mov	ebx, [esp+0]
retn
__x86_get_pc_thunk_bx endp

align 10h


; Attributes: bp-based frame

deregister_tm_clones proc near
mov	eax, 804C03Fh
sub	eax, 804C03Ch
cmp	eax, 6
jbe	short locret_8048579									; Faz um salto curto (para um local próximo) até a subrotina "locret_8048579" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short locret_8048579									; Faz um salto curto (para um local próximo) até a subrotina "locret_8048579" se a zero flag estiver setada. (ZF = 1)
push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 14h
push	804C03Ch
call	eax
add	esp, 10h
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha

locret_8048579:
rep retn
deregister_tm_clones endp ; sp =  4

align 10h


; Attributes: bp-based frame

register_tm_clones proc	near
mov	eax, 804C03Ch
sub	eax, 804C03Ch
sar	eax, 2
mov	edx, eax    											; Copia valor de EAX parar EDX
shr	edx, 1Fh    											; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
sar	eax, 1
jz	short locret_80485B3									; Faz um salto curto (para um local próximo) até a subrotina "locret_80485B3" se a zero flag estiver setada. (ZF = 1)
mov	edx, 0
test	edx, edx
jz	short locret_80485B3									; Faz um salto curto (para um local próximo) até a subrotina "locret_80485B3" se a zero flag estiver setada. (ZF = 1)
push	ebp   												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 10h
push	eax    												;  Empilha valor de EAX
push	804C03Ch
call	edx
add	esp, 10h
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha

locret_80485B3:
rep retn
register_tm_clones endp	; sp =	4

align 10h


; Attributes: bp-based frame

__do_global_dtors_aux proc near
cmp	ds:completed_7200, 0
jnz	short locret_80485DC									; Faz um salto curto (para um local próximo) até a subrotina "locret_80485DC". Se a ZF não estiver setada. (ZF = 0)
push	ebp   												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
call	deregister_tm_clones								; Faz uma chamada para a subrotina "deregister_tm_clones"
mov	ds:completed_7200, 1
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha

locret_80485DC:
rep retn
__do_global_dtors_aux endp ; sp	=  4

align 10h


; Attributes: bp-based frame

frame_dummy proc near
mov	eax, offset __JCR_LIST__
mov	edx, [eax]
test	edx, edx
jnz	short													; Faz um salto curto (para um local próximo) até a subrotina "short". Se a ZF não estiver setada. (ZF = 0) loc_80485F0

loc_80485EB:
jmp	short register_tm_clones								; Faz um salto curto (para um local próximo) até a subrotina "register_tm_clones"
align 10h

loc_80485F0:
mov	edx, 0
test	edx, edx
jz	short loc_80485EB										; Faz um salto curto (para um local próximo) até a subrotina "loc_80485EB" se a zero flag estiver setada. (ZF = 1)
push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 14h
push	eax    												; Empilha valor de EAX
call	edx
add	esp, 10h
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
jmp	register_tm_clones										; Salta para a subrotina "register_tm_clones"
frame_dummy endp


; ####### FUNÇÕES INTERNAS UTILIZADAS NO JOGO

; Attributes: bp-based frame

public main
main proc near

arg_0= dword ptr  4

lea	ecx, [esp+arg_0]
and	esp, 0FFFFFFF0h   										; Realiza operação booleana "AND" bit-a-bit e armazena valor lógico em ESP
push	dword ptr [ecx-4]
push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
push	ecx    												; Empilha valor de ECX
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP

loc_804861C:
call	initialise											; Faz uma chamada para a subrotina "initialise"
jmp	short loc_804863D										; Faz um salto curto (para um local próximo) até a subrotina "loc_804863D"

loc_8048623:
call	display												; Faz uma chamada para a subrotina "display"
call	manage_input										; Faz uma chamada para a subrotina "manage_input"
movzx	eax, ds:is_clicked
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_804863D										; Faz um salto curto (para um local próximo) até a subrotina "loc_804863D" se a zero flag estiver setada. (ZF = 1)
call	process												; Faz uma chamada para a subrotina "process"

loc_804863D:
movzx	eax, ds:cur_player
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax													; Empilha valor de EAX
call	is_game_over										; Faz uma chamada para a subrotina "is_game_over"
add	esp, 10h
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048623										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048623" se a zero flag estiver setada. (ZF = 1)
call	display												; Faz uma chamada para a subrotina "display"
call	game_over											; Faz uma chamada para a subrotina "game_over"
jmp	short loc_804861C										; Faz um salto curto (para um local próximo) até a subrotina "loc_804861C"
main endp



; Attributes: bp-based frame

public display
display	proc near

var_18B= byte ptr -18Bh
var_18A= byte ptr -18Ah
var_189= byte ptr -189h
var_188= byte ptr -188h
var_187= byte ptr -187h
var_186= byte ptr -186h
var_185= byte ptr -185h
var_184= dword ptr -184h
var_180= dword ptr -180h
var_17A= dword ptr -17Ah
var_1C=	dword ptr -1Ch
var_18=	dword ptr -18h
var_C= dword ptr -0Ch

push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
push	edi    												; Empilha valor de EDI
push	esi    												; Empilha ES    ; Empilha valor EBX
push	ebx
sub	esp, 18Ch
mov	eax, large gs:14h
mov	[ebp+var_1C], eax
xor	eax, eax
mov	[ebp+var_18B], 6
mov	[ebp+var_18A], 0Eh
lea	eax, [ebp+var_17A]
mov	ebx, offset asc_804A2A0	; "	    "
mov	edx, 15Eh
mov	ecx, [ebx]
mov	[eax], ecx
mov	ecx, [ebx+edx-4]
mov	[eax+edx-4], ecx
lea	edi, [eax+4]
and	edi, 0FFFFFFFCh
sub	eax, edi
sub	ebx, eax
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
and	edx, 0FFFFFFFCh
mov	eax, edx    											; Copia valor de EDX para EAX
shr	eax, 2
mov	esi, ebx
mov	ecx, eax    											; Copia valor de ECX para EAX
rep movsd
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
mov	[ebp+var_189], al
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	[ebp+var_188], al
movzx	eax, ds:cur_player
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_80486F0										; Faz um salto curto (para um local próximo) até a subrotina "loc_80486F0" se a zero flag estiver setada. (ZF = 1)
mov	eax, offset aTrue ; "TRUE"
jmp	short loc_80486F5										; Faz um salto curto (para um local próximo) até a subrotina "loc_80486F5"

loc_80486F0:		; "FALSE"
mov	eax, offset aFalse

loc_80486F5:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
push	offset aCur_playerS ; "cur_player   == %s\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, ds:has_selected
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048718										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048718" se a zero flag estiver setada. (ZF = 1)
mov	eax, offset aTrue ; "TRUE"
jmp	short loc_804871D										; Faz um salto curto (para um local próximo) até a subrotina "loc_804871D"

loc_8048718:		; "FALSE"
mov	eax, offset aFalse

loc_804871D:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
push	offset aHas_selectedS ;	"has_selected == %s\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, ds:is_clicked
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048740										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048740" se a zero flag estiver setada. (ZF = 1)
mov	eax, offset aTrue ; "TRUE"
jmp	short loc_8048745										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048745"

loc_8048740:		; "FALSE"
mov	eax, offset aFalse

loc_8048745:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    												; Empilha valor de EAX
push	offset aIs_clickedS ; "is_clicked   == %s\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, ds:selected_pos  ; Copia valor de "ds:selected_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	edx, eax    											; Copia valor de EAX parar EDX
movzx	eax, ds:selected_pos  ; Copia valor de "ds:selected_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's    							; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	edx    												; Empilha valor de EDX
push	eax    												; Empilha valor de EAX
push	offset aSelected_posDD ; "selected_pos == (%d,%d);\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	edx, eax    											; Copia valor de EAX parar EDX
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's   								; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4  												; Subtrai 4 (em decimal) bytes do valor de ESP
push	edx    												; Empilha valor de EDX
push	eax    												;  Empilha valor de EAX
push	offset aCurrent_posDD ;	"current_pos  == (%d,%d);\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, ds:en_passant_flag
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    												; Empilha valor de EAX
push	offset aEn_paasant_fla ; "en_paasant_flag  == %d;\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, ds:castle_flag 								; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    												; Empilha valor de EAX
push	offset aCastle_flagD ; "castle_flag	 == %d;\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
movzx	eax, [ebp+var_18B]    								; Copia valor apontado por [EBP+var_18B] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shl	eax, 3
mov	[ebp+var_184], eax										; Copia valor de EAX para o valor referenciado por [EBP+var_184]
jmp	loc_8048BD5												; Faz um salto incondicional até a subrotina "loc_8048BD5"

loc_80487FD:
mov	[ebp+var_180], 0
jmp	loc_8048BA8												; Faz um salto incondicional até a subrotina "loc_8048BA8"

loc_804880C:
movzx	edi, [ebp+var_18B]   	 							; Copia valor apontado por [EBP+var_18B] para EDI, estendendo a parte mais sigificativa de EDI com 0's
mov	eax, [ebp+var_184]    									; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cdq
idiv	edi
mov	[ebp+var_187], al
movzx	ebx, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	ebx
mov	[ebp+var_186], al
movzx	eax, [ebp+var_186]
movzx	edx, al  											; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, [ebp+var_187]
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    												; Empilha valor de EDX
push	eax   												; Empilha valor de EAX
call	to_pos												; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
mov	[ebp+var_185], al
movzx	ecx, [ebp+var_18B]
mov	eax, [ebp+var_184]    									; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	short loc_804889D										; Faz um salto curto (para um local próximo) até a subrotina "loc_804889D". Se a ZF não estiver setada. (ZF = 0)
movzx	ecx, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	short loc_804889D										; Faz um salto curto (para um local próximo) até a subrotina "loc_804889D". Se a ZF não estiver setada. (ZF = 0)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	2Bh		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_804889D:
movzx	ecx, [ebp+var_18B]
mov	eax, [ebp+var_184]    									; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	loc_8048943												; Faz um salto até a subrotina "loc_8048943" se a zero flag não estiver setada. (ZF = 0)
movzx	eax, [ebp+var_187]
cmp	al, [ebp+var_189]
jz	short loc_80488DB										; Faz um salto curto (para um local próximo) até a subrotina "loc_80488DB" se a zero flag estiver setada. (ZF = 1)
movsx	eax, [ebp+var_187]
movsx	edx, [ebp+var_189]
add	edx, 1
cmp	eax, edx
jnz	short													; Faz um salto curto (para um local próximo) até a subrotina "short". Se a ZF não estiver setada. (ZF = 0) loc_8048912

loc_80488DB:
movzx	eax, [ebp+var_186]
cmp	al, [ebp+var_188]
jnz	short loc_8048912										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048912". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:has_selected
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_80488FC										; Faz um salto curto (para um local próximo) até a subrotina "loc_80488FC" se a zero flag estiver setada. (ZF = 1)
mov	eax, 23h
jmp	short loc_8048901										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048901"

loc_80488FC:
mov	eax, 40h

loc_8048901:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax		; int										; Empilha valor de EAX
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048912:
mov	eax, [ebp+var_180]
and	eax, 1
test	eax, eax											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8048931										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048931" se a zero flag estiver setada. (ZF = 1)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	20h		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048931:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	2Dh		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048943:
movzx	ecx, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	loc_80489E9												; Faz um salto até a subrotina "loc_80489E9" se a zero flag não estiver setada. (ZF = 0)
movzx	eax, [ebp+var_186]
cmp	al, [ebp+var_188]
jz	short loc_8048981										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048981" se a zero flag estiver setada. (ZF = 1)
movsx	eax, [ebp+var_186]
movsx	edx, [ebp+var_188]
add	edx, 1
cmp	eax, edx
jnz	short													; Faz um salto curto (para um local próximo) até a subrotina "short". Se a ZF não estiver setada. (ZF = 0) loc_80489B8

loc_8048981:
movzx	eax, [ebp+var_187]
cmp	al, [ebp+var_189]
jnz	short loc_80489B8										; Faz um salto curto (para um local próximo) até a subrotina "loc_80489B8". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:has_selected
test	al, al												; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_80489A2										; Faz um salto curto (para um local próximo) até a subrotina "loc_80489A2" se a zero flag estiver setada. (ZF = 1)
mov	eax, 23h
jmp	short loc_80489A7										; Faz um salto curto (para um local próximo) até a subrotina "loc_80489A7"

loc_80489A2:
mov	eax, 40h

loc_80489A7:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax		; int										;  Empilha valor de EAX
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_80489B8:
mov	eax, [ebp+var_184]    									; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 1
test	eax, eax											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_80489D7										; Faz um salto curto (para um local próximo) até a subrotina "loc_80489D7" se a zero flag estiver setada. (ZF = 1)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	20h		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_80489D7:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	7Ch		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_80489E9:
mov	eax, [ebp+var_180]
add	eax, 1
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax  											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8048A63										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048A63" se a zero flag estiver setada. (ZF = 1)
mov	eax, [ebp+var_180]
lea	edx, [eax-1]
movzx	eax, [ebp+var_18A]
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8048A63										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048A63" se a zero flag estiver setada. (ZF = 1)
mov	eax, [ebp+var_180]
add	eax, 2
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax  											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8048A63										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048A63" se a zero flag estiver setada. (ZF = 1)
mov	eax, [ebp+var_180]
lea	edx, [eax-2]
movzx	eax, [ebp+var_18A]
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	ecx, [ebp+var_18A]
cdq
idiv	ecx
mov	eax, edx    											; Copia valor de EDX para EAX
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	loc_8048AF5												; Faz um salto até a subrotina "loc_8048AF5" se a zero flag não estiver setada. (ZF = 0)

loc_8048A63:
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	[ebp+var_185], al
jnz	short loc_8048A9A										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048A9A". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:has_selected
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048A84										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048A84" se a zero flag estiver setada. (ZF = 1)
mov	eax, 23h
jmp	short loc_8048A89										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048A89"

loc_8048A84:
mov	eax, 40h

loc_8048A89:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax		; int   									; Empilha valor de EAX
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048A9A:
movzx	eax, ds:selected_pos  ; Copia valor de "ds:selected_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	[ebp+var_185], al
jnz	short loc_8048ABB										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048ABB". Se a ZF não estiver setada. (ZF = 0)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	2Ah		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048ABB:
mov	edx, ds:are_marked									; Copia valor de "ds:are_marked" para EDX
movzx	eax, [ebp+var_185]
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048AE3										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048AE3" se a zero flag estiver setada. (ZF = 1)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	24h		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048AE3:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	20h		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	loc_8048BA1												; Faz um salto incondicional até a subrotina "loc_8048BA1"

loc_8048AF5:
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_185]
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	ebx, al
movzx	ecx, [ebp+var_18B]
movzx	esi, [ebp+var_18B]
mov	eax, [ebp+var_184]    									; Copia valor apontado por [EBP+var_184] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cdq
idiv	esi
mov	eax, edx    											; Copia valor de EDX para EAX
sub	ecx, eax    											; Subtrai valor de EAX em ECX, armazena em ECX
mov	eax, ecx    											; Copia valor de ECX para EAX
lea	ecx, [eax-1]
movzx	esi, [ebp+var_18A]
mov	eax, [ebp+var_180]
cdq
idiv	esi
mov	eax, edx    											; Copia valor de EDX para EAX
lea	esi, [eax-3]
mov	eax, ecx    											; Copia valor de ECX para EAX
shl	eax, 2
add	eax, ecx    											; Soma valor de EAX com ECX, e armazena em EAX
add	eax, eax
imul	edx, ebx, 32h
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
lea	edi, [ebp+var_18]
add	eax, edi
add	eax, esi
sub	eax, 162h
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, 20h
jnz	short loc_8048B6F										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048B6F". Se a ZF não estiver setada. (ZF = 0)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	20h		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	short loc_8048BA1										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048BA1"

loc_8048B6F:
mov	edx, ds:cells_side
movzx	eax, [ebp+var_185]
add	eax, edx    											; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al  											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048B94										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048B94" se a zero flag estiver setada. (ZF = 1)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	4Fh		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h
jmp	short loc_8048BA1										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048BA1"

loc_8048B94:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	58h		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h

loc_8048BA1:
add	[ebp+var_180], 1

loc_8048BA8:
movzx	eax, [ebp+var_18A]
shl	eax, 3
add	eax, 1
cmp	eax, [ebp+var_180]
jg	loc_804880C
sub	[ebp+var_184], 1
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	0Ah		; int
call	_putchar											; Faz uma chamada para a subrotina "_putchar"
add	esp, 10h

loc_8048BD5:
cmp	[ebp+var_184], 0
jns	loc_80487FD
nop
mov	eax, [ebp+var_1C]
xor	eax, large gs:14h
jz	short loc_8048BF4										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048BF4" se a zero flag estiver setada. (ZF = 1)
call	___stack_chk_fail									; Faz uma chamada para a subrotina "___stack_chk_fail"

loc_8048BF4:
lea	esp, [ebp-0Ch]
pop	ebx   													; Desempilha EBX
pop	esi   													; Desempilha ESI
pop	edi   													; Desempilha EDI
pop	ebp   													; Desempilha EBP
retn
display	endp



; Attributes: bp-based frame

public manage_input
manage_input proc near

var_10=	byte ptr -10h
var_F= byte ptr	-0Fh
var_E= byte ptr	-0Eh
var_C= dword ptr -0Ch

push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 18h
mov	eax, large gs:14h
mov	[ebp+var_C], eax
xor	eax, eax
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
mov	[ebp+var_10], al
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	[ebp+var_F], al
mov	ds:is_clicked, 0
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset aGetInputAswdFo ; "Get input (aswd for direction, f for cl"...
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
lea	eax, [ebp-0Eh]
push	eax    												; Empilha valor de EAX
push	offset aS	; "%s"
call	___isoc99_scanf
add	esp, 10h
movzx	eax, [ebp+var_E]    								; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	eax, 61h	; switch 23 cases
cmp	eax, 16h
ja	loc_8048CEB	; default
mov	eax, ds:off_804A450[eax*4]
jmp	eax		; switch jump

loc_8048C6E:		; case 0x61
movsx	eax, [ebp+var_F]
lea	edx, [eax+7]
mov	eax, edx    											; Copia valor de EDX para EAX
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
and	edx, 7
sub	edx, eax    											; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    											; Copia valor de EDX para EAX
mov	[ebp+var_F], al
jmp	short loc_8048D03										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048D03"

loc_8048C8B:		; case 0x64
movsx	eax, [ebp+var_F]
lea	edx, [eax+9]
mov	eax, edx    											; Copia valor de EDX para EAX
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
and	edx, 7
sub	edx, eax    											; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    											; Copia valor de EDX para EAX
mov	[ebp+var_F], al
jmp	short loc_8048D03										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048D03"

loc_8048CA8:		; case 0x73
movsx	eax, [ebp+var_10]
lea	edx, [eax+7]
mov	eax, edx    											; Copia valor de EDX para EAX
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
and	edx, 7
sub	edx, eax    											; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    											; Copia valor de EDX para EAX
mov	[ebp+var_10], al
jmp	short loc_8048D03										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048D03"

loc_8048CC5:		; case 0x77
movsx	eax, [ebp+var_10]
lea	edx, [eax+9]
mov	eax, edx    											; Copia valor de EDX para EAX
sar	eax, 1Fh
shr	eax, 1Dh
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
and	edx, 7
sub	edx, eax    											; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    											; Copia valor de EDX para EAX
mov	[ebp+var_10], al
jmp	short loc_8048D03										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048D03"

loc_8048CE2:		; case 0x66
mov	ds:is_clicked, 1
jmp	short loc_8048D03										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048D03"

loc_8048CEB:		; default
mov	eax, ds:stderr@@GLIBC_2_0
push	eax		; FILE *    								;  Empilha valor de EAX
push	1Ah		; n
push	1		; size
push	offset aCannotRecognis ; "cannot recognise the input"
call	_fwrite
add	esp, 10h
nop

loc_8048D03:
movzx	eax, [ebp+var_F]    								; Copia valor apontado por [EBP+var_F] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, al   											; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, [ebp+var_10]   								; Copia valor apontado por [EBP+var_10] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    												; Empilha valor de EDX
push	eax   												;  Empilha valor de EAX
call	to_pos												; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
mov	ds:current_pos,	al
nop
mov	eax, [ebp+var_C]
xor	eax, large gs:14h
jz	short locret_8048D35									; Faz um salto curto (para um local próximo) até a subrotina "locret_8048D35" se a zero flag estiver setada. (ZF = 1)
call	___stack_chk_fail									; Faz uma chamada para a subrotina "___stack_chk_fail"

locret_8048D35:
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
manage_input endp



; Attributes: bp-based frame

public promote_pawn
promote_pawn proc near

var_E= byte ptr	-0Eh
var_C= dword ptr -0Ch

push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 18h
mov	eax, large gs:14h
mov	[ebp+var_C], eax
xor	eax, eax
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset aTheCurrentPawn ; "The current pawn is promoting... "
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset aWhichTypeThatY ; "Which	type that you want your	pawn to	b"...
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset aAKnightSBishop ; "a(knight) s(bishop) d(rook) w(queen) : "...
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
lea	eax, [ebp-0Eh]
push	eax    												; Empilha valor de EAX
push	offset aS	; "%s"
call	___isoc99_scanf
add	esp, 10h
movzx	eax, [ebp+var_E]    								; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	eax, 64h
jz	short loc_8048DB7										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DB7" se a zero flag estiver setada. (ZF = 1)
cmp	eax, 64h
jg	short loc_8048DA4
cmp	eax, 61h
jz	short loc_8048DB0										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DB0" se a zero flag estiver setada. (ZF = 1)
jmp	short loc_8048DCC										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DCC"

loc_8048DA4:
cmp	eax, 73h
jz	short loc_8048DC5										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DC5" se a zero flag estiver setada. (ZF = 1)
cmp	eax, 77h
jz	short loc_8048DBE										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DBE" se a zero flag estiver setada. (ZF = 1)
jmp	short loc_8048DCC										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DCC"

loc_8048DB0:
mov	eax, 2													; Copia 2 para EAX
jmp	short loc_8048DE8										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048DE8"

loc_8048DB7:
mov	eax, 3 													; Copia 3 para EAX
jmp	short loc_8048DE8

loc_8048DBE:
mov	eax, 4													; Copia 4 para EAX
jmp	short loc_8048DE8

loc_8048DC5:
mov	eax, 5													; Copia 5 para EAX
jmp	short loc_8048DE8

loc_8048DCC:
mov	eax, ds:stderr@@GLIBC_2_0
push	eax		; FILE *    								; Empilha valor de EAX
push	1Ah		; n
push	1		; size
push	offset aCannotRecognis ; "cannot recognise the input"
call	_fwrite
add	esp, 10h
mov	eax, 0    ; Copia 0 para EAXFFFFFFFFh

loc_8048DE8:
mov	edx, [ebp+var_C]
xor	edx, large gs:14h
jz	short locret_8048DF9									; Faz um salto curto (para um local próximo) até a subrotina "locret_8048DF9" se a zero flag estiver setada. (ZF = 1)
call	___stack_chk_fail									; Faz uma chamada para a subrotina "___stack_chk_fail"

locret_8048DF9:
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
promote_pawn endp



; Attributes: bp-based frame

public game_over
game_over proc near
push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	ecx, al   											; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, al   											; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	ecx    												; Empilha valor de ECX
push	edx    												; Empilha valor de EDX
push	eax    												; Empilha valor de EAX
call	is_in_check											; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8048E9B										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048E9B" se a zero flag estiver setada. (ZF = 1)
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A528 ; "\n"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A52A ; "*****************************"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
movzx	eax, ds:cur_player
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_8048E63										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048E63". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 58h
jmp	short loc_8048E68

loc_8048E63:
mov	eax, 4Fh

loc_8048E68:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
push	offset aGameOverPlayer ; "* Game Over Player %c	win. *\n"
call	_printf												; Faz uma chamada para a subrotina "_printf"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A52A ; "*****************************"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A566 ; "\n\n\n\n"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
jmp	short loc_8048EEB

loc_8048E9B:
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A528 ; "\n"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A56B ; "***********************"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset aGameOverStalem ; "* Game Over Stalemate	*"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A56B ; "***********************"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset asc_804A566 ; "\n\n\n\n"
call	_puts												; Faz uma chamada para a subrotina "_puts"
add	esp, 10h

loc_8048EEB:
nop
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
game_over endp



; Attributes: bp-based frame

public initialise
initialise proc	near
push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
mov	ds:cur_player, 0
mov	ds:has_selected, 0      ; Copia 0 para "ds:has_selected"
mov	ds:is_clicked, 0
mov	ds:en_passant_flag, 0FFh
mov	ds:castle_flag,	0
mov	ds:selected_pos, 0FFh					; Copia 0FFh(255 em decimal) para "ds:selected_pos"
mov	ds:current_pos,	24h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	40h		; size
call	_malloc												; Faz uma chamada para a subrotina "_malloc"
add	esp, 10h
mov	ds:cells_type, eax
mov	eax, ds:cells_type
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	short loc_8048F59										; Faz um salto curto (para um local próximo) até a subrotina "loc_8048F59". Se a ZF não estiver setada. (ZF = 0)
push	offset __PRETTY_FUNCTION___2748	; "initialise"
push	0F3h
push	offset aProgram_c ; "program.c"
push	offset aCells_typeNull ; "cells_type !=	NULL"
call	___assert_fail										; Faz uma chamada para a subrotina "___assert_fail"

loc_8048F59:
mov	eax, ds:cells_type     									; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	40h		; size_t
push	0		; int
push	eax		; void *    								; Empilha valor de EAX
call	_memset												; Faz uma chamada para a subrotina "_memset"
add	esp, 10h
mov	eax, ds:cells_type
add	eax, 8     												; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	8		; size_t
push	1		; int
push	eax		; void *    								;  Empilha valor de EAX
call	_memset												; Faz uma chamada para a subrotina "_memset"
add	esp, 10h
mov	eax, ds:cells_type
add	eax, 30h     											; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	8		; size_t
push	1		; int
push	eax		; void *    								;  Empilha valor de EAX
call	_memset												; Faz uma chamada para a subrotina "_memset"
add	esp, 10h
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
mov	eax, ds:cells_type										; Copia valor de "ds:cells_type" para EAX
add	eax, 38h
mov	byte ptr [eax],	4
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+1]
mov	eax, ds:cells_type
add	eax, 39h
mov	byte ptr [eax],	2
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+2]
mov	eax, ds:cells_type
add	eax, 3Ah
mov	byte ptr [eax],	3
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+3]
mov	eax, ds:cells_type
add	eax, 3Bh
mov	byte ptr [eax],	5
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+4]
mov	eax, ds:cells_type
add	eax, 3Ch
mov	byte ptr [eax],	6
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+5]
mov	eax, ds:cells_type
add	eax, 3Dh
mov	byte ptr [eax],	3
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+6]
mov	eax, ds:cells_type
add	eax, 3Eh
mov	byte ptr [eax],	2
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	eax, ds:cells_type
lea	edx, [eax+7]
mov	eax, ds:cells_type
add	eax, 3Fh
mov	byte ptr [eax],	4
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	40h		; size
call	_malloc												; Faz uma chamada para a subrotina "_malloc"
add	esp, 10h
mov	ds:are_marked, eax
mov	eax, ds:are_marked
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	short loc_8049090										; Faz um salto curto (para um local próximo) até a subrotina "loc_8049090". Se a ZF não estiver setada. (ZF = 0)
push	offset __PRETTY_FUNCTION___2748	; "initialise"
push	101h
push	offset aProgram_c ; "program.c"
push	offset aAre_markedNull ; "are_marked !=	NULL"
call	___assert_fail										; Faz uma chamada para a subrotina "___assert_fail"

loc_8049090:
mov	eax, ds:are_marked     									; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	40h		; size_t
push	0		; int
push	eax		; void *    								;  Empilha valor de EAX
call	_memset												; Faz uma chamada para a subrotina "_memset"
add	esp, 10h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	40h		; size
call	_malloc												; Faz uma chamada para a subrotina "_malloc"
add	esp, 10h
mov	ds:cells_side, eax
mov	eax, ds:cells_side
test	eax, eax   											; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jnz	short loc_80490D9										; Faz um salto curto (para um local próximo) até a subrotina "loc_80490D9". Se a ZF não estiver setada. (ZF = 0)
push	offset __PRETTY_FUNCTION___2748	; "initialise"
push	105h
push	offset aProgram_c ; "program.c"
push	offset aCells_sideNull ; "cells_side !=	NULL"
call	___assert_fail										; Faz uma chamada para a subrotina "___assert_fail"

loc_80490D9:
mov	eax, ds:cells_side    									; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	20h		; size_t
push	0		; int
push	eax		; void *    								; Empilha valor de EAX
call	_memset												; Faz uma chamada para a subrotina "_memset"
add	esp, 10h
mov	eax, ds:cells_side
add	eax, 20h     											; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	20h		; size_t
push	1		; int
push	eax		; void *    								; Empilha valor de EAX
call	_memset												; Faz uma chamada para a subrotina "_memset"
add	esp, 10h
nop
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
initialise endp



; Attributes: bp-based frame

public is_game_over											; Declaração da subrotina "is_game_over". Ela finaliza o jogo.
is_game_over proc near

var_1C=	byte ptr -1Ch
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
arg_0= dword ptr  8

push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 28h  ; Subtrai 28h (20 bytes, em decimal) de ESP, armazena em ESP
mov	eax, [ebp+arg_0]    									; Copia valor referenciado por [EBP+var_4] para EAX
mov	[ebp+var_1C], al    									; Copia valor de AL para endereço apontado por [EBP+var_1C]
movzx	eax, ds:cur_player									; Copia valor de "ds:cur_player" para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[ebp+var_9], al   										; Copia valor de AL para endereço apontado por [EBP+var_9]
movzx	eax, [ebp+var_1C]   								; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	ds:cur_player, al					; Copia valor de AL para "ds:cur_player"
mov	[ebp+var_C], 1
mov	[ebp+var_B], 0
jmp	loc_80491CC												; Faz um salto incondicional até a subrotina "loc_80491CC"

loc_8049135:
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_80491C2										; Faz um salto curto (para um local próximo) até a subrotina "loc_80491C2" se a zero flag estiver setada. (ZF = 1)
mov	edx, ds:cells_side
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

add	eax, edx    										 	; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_1C]    									; Compara valor de EDX com EAX, e modifica ZF e CF
jnz	short loc_80491C2										; Faz um salto curto (para um local próximo) até a subrotina "loc_80491C2". Se a ZF não estiver setada. (ZF = 0)
mov	[ebp+var_A], 0
jmp	short loc_80491BC

loc_8049162:
movzx	ecx, [ebp+var_A]
movzx	edx, [ebp+var_B]
movzx	eax, [ebp+var_1C]    								;Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	ecx    												; Empilha valor de ECX
push	edx    												; Empilha valor de EDX
push	eax    												; Empilha valor de EAX
call	is_in_check											; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_804919B										; Faz um salto curto (para um local próximo) até a subrotina "loc_804919B". Se a ZF não estiver setada. (ZF = 0)
movzx	edx, [ebp+var_A]  ; Copia valor apontado por [EBP+var_A] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's
     								; Copia valor de AL para EAX, preenchendo
sub	esp, 4   												; Subtrai 4 (em decimal) bytes do valor de ESP
push	0
push	edx    												; Empilha valor de EDX
push	eax    												; Empilha valor de EAX
call	legal_move											;Faz uma chamada para a subrotina legal_move
add	esp, 10h
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_80491A2										; Faz um salto curto (para um local próximo) até a subrotina "short". Se a ZF não estiver setada. (ZF = 0) loc_80491A2

loc_804919B:
mov	eax, 1    ; Copia 1 para EAX
jmp	short loc_80491A7

loc_80491A2:
mov	eax, 0    ; Copia 0 para EAX

loc_80491A7:
mov	edx, eax    											; Copia valor de EAX parar EDX
movzx	eax, [ebp+var_C]    								; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, edx    											; Aplica a operação booleana AND entre valores de EAX e EDX, armazena resultado em EAX
mov	[ebp+var_C], al
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 1
mov	[ebp+var_A], al   										; Copia valor de AL para endereço apontado por [EBP+var_A]

loc_80491BC:
cmp	[ebp+var_A], 3Fh  ; Compara valor referenciado por [EBP+var_A], e modifica ZF e CF
jbe	short loc_8049162										; Faz um salto curto (para um local próximo) até a subrotina "loc_8049162" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)

loc_80491C2:
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

add	eax, 1
mov	[ebp+var_B], al ; Copia Valor de AL para referenciado por [EBP+var_B]

loc_80491CC:
cmp	[ebp+var_B], 3Fh
jbe	loc_8049135
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	ds:cur_player, al					; Copia valor de AL para "ds:cur_player"
movzx	eax, [ebp+var_C]   								 ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
is_game_over endp



; Attributes: bp-based frame

public process
process	proc near

var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_4= dword ptr -4

push	ebp    											; Empilha valor de EBP
mov	ebp, es   											; Empilha valor EBX
push	ebx
sub	esp, 14h
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, 3Fh  ; Compara AL com 3Fh (63 em decimal), e modifica ZF e CF
jbe	short loc_8049210									; Faz um salto curto (para um local próximo) até a subrotina "loc_8049210" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
push	offset __PRETTY_FUNCTION___2764				; Empilha valor de "__PRETTY_FUNCTION___2764"
push	118h
push	offset aProgram_c ; "program.c" -- "Empilha valor de aProgram_c"
push	offset a0Current_posCu ; "0 <= current_pos && current_pos < BOARD"...
call	___assert_fail									; Faz uma chamada para a subrotina "___assert_fail"

loc_8049210:
movzx	eax, ds:has_selected
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	loc_80492D1											; Faz um salto até a subrotina "loc_80492D1" se a zero flag não estiver setada. (ZF = 0)
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    											; Empilha valor de EAX
call	is_own_piece									; Faz uma chamada para a subrotina "is_own_piece"
add	esp, 10h
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	loc_8049407
mov	[ebp+var_A], 0
jmp	short loc_80492B3

loc_8049243:
mov	edx, ds:are_marked									; Copia valor de "ds:are_marked" para EDX
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
lea	ebx, [edx+eax]
movzx	ecx, [ebp+var_A]
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, al   										; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   											; Subtrai 4 (em decimal) bytes do valor de ESP
push	ecx    											; Empilha valor de ECX
push	edx    											; Empilha valor de EDX
push	eax    											;  Empilha valor de EAX
call	is_in_check										; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_80492A2									; Faz um salto curto (para um local próximo) até a subrotina "loc_80492A2". Se a ZF não estiver setada. (ZF = 0)
movzx	edx, [ebp+var_A]  ; Copia valor apontado por [EBP+var_A] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   											; Subtrai 4 (em decimal) bytes do valor de ESP
push	0
push	edx    											; Empilha valor de EDX
push	eax    											; Empilha valor de EAX
call	legal_move										; Faz uma chamada para a subrotina "legal_move"
add	esp, 10h
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_80492A2									; Faz um salto curto (para um local próximo) até a subrotina "loc_80492A2" se a zero flag estiver setada. (ZF = 1)
mov	eax, 1    ; Copia 1 para EAX
jmp	short loc_80492A7

loc_80492A2:
mov	eax, 0    ; Copia 0 para EAX

loc_80492A7:
mov	[ebx], al ; Copia Valor de AL para referenciado por [EBX]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 1
mov	[ebp+var_A], al   									; Copia valor de AL para endereço apontado por [EBP+var_A]

loc_80492B3:
cmp	[ebp+var_A], 3Fh  ; Compara valor referenciado por [EBP+var_A], e modifica ZF e CF
jbe	short loc_8049243									; Faz um salto curto (para um local próximo) até a subrotina "loc_8049243" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	ds:selected_pos, al     ; Copia valor de AL para "ds:selected_pos"
mov	ds:has_selected, 1      ; Copia 1(em decimal) para "ds:has_selected"
jmp	loc_8049408											; Faz um salto incondicional até a subrotina "loc_8049408"

loc_80492D1:
movzx	eax, ds:selected_pos  ; Copia valor de "ds:selected_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, 3Fh  ; Compara AL com 3Fh (63 em decimal), e modifica ZF e CF
jbe	short loc_80492F5									; Faz um salto curto (para um local próximo) até a subrotina "loc_80492F5" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
push	offset __PRETTY_FUNCTION___2764
push	122h				; Empilha 122h (290 em decimal)
push	offset aProgram_c 	; "program.c"
push	offset a0Selected_posS ; "0 <= selected_pos && selected_pos < BOA"... -- Empilha valor de "a0Selected_posS"
call	___assert_fail									; Faz uma chamada para a subrotina "___assert_fail"

loc_80492F5:
mov	edx, ds:are_marked									; Copia valor de "ds:are_marked" para EDX
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	loc_80493D2
movzx	eax, ds:current_pos   ; Copia valor de "ds:current_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, al   										; Copia valor apontado por AL para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, ds:selected_pos  ; Copia valor de "ds:selected_pos" para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   											; Subtrai 4 (em decimal) bytes do valor de ESP
push	1
push	edx    											; Empilha valor de EDX
push	eax    											; Empilha valor de EAX
call	legal_move										; Faz uma chamada para a subrotina "legal_move"
add	esp, 10h
movzx	eax, ds:cur_player
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
setz	al	; Copia valor 1 para AL se ZF=1, copia 0 caso contrário
mov	ds:cur_player, al					; Copia valor de AL para "ds:cur_player"
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	offset aChangeTurn ; "change turn"
call	_puts											; Faz uma chamada para a subrotina "_puts"
add	esp, 10h
movzx	eax, ds:cur_player
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
setz	al	; Copia valor 1 para AL se ZF=1, copia 0 caso contrário
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   											; Subtrai 4 (em decimal) bytes do valor de ESP
push	0
push	0
push	eax    											;  Empilha valor de EAX
call	is_in_check										; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al  										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049399									; Faz um salto curto (para um local próximo) até a subrotina "loc_8049399" se a zero flag estiver setada. (ZF = 1)
movzx	eax, ds:cur_player
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
setz	al	; Copia valor 1 para AL se ZF=1, copia 0 caso contrário
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    											; Empilha valor de EAX
push	offset aPlayerDYouAreI ; "Player %d, you are in	check!!!\n" -- Empilha valor de "aPlayerDYouAreI"
call	_printf											; Faz uma chamada para a subrotina "_printf"
add	esp, 10h

loc_8049399:
movzx	eax, ds:cur_player
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   											; Subtrai 4 (em decimal) bytes do valor de ESP
push	0
push	0
push	eax    											;  Empilha valor de EAX
call	is_in_check										; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   										; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_80493D2									; Faz um salto curto (para um local próximo) até a subrotina "loc_80493D2" se a zero flag estiver setada. (ZF = 1)
movzx	eax, ds:cur_player
movzx	eax, al   										; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	eax    											; Empilha valor de EAX
push	offset aPlayerDYouAreI ; "Player %d, you are in	check!!!\n"
call	_printf											; Faz uma chamada para a subrotina "_printf"
add	esp, 10h

loc_80493D2:
mov	[ebp+var_9], 0  ; Copia 0 para referenciado por [EBP+var_9]
jmp	short loc_80493F1

loc_80493D8:
mov	edx, ds:are_marked									; Copia valor de "ds:are_marked" para EDX
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     										; Soma valor de EAX com EDX, e armazena em EAX
mov	byte ptr [eax],	0   ; Copia O para o 1º byte do valor apontado por [EAX] para EAX
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 1
mov	[ebp+var_9], al   									; Copia valor de AL para endereço apontado por [EBP+var_9]

loc_80493F1:
cmp	[ebp+var_9], 3Fh
jbe	short loc_80493D8									; Faz um salto curto (para um local próximo) até a subrotina "loc_80493D8" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
mov	ds:selected_pos, 0FFh					; Copia 0FFh(255 em decimal) para "ds:selected_pos"
mov	ds:has_selected, 0      ; Copia 0 para "ds:has_selected"
jmp	short loc_8049408

loc_8049407:
nop

loc_8049408:
mov	ebx, [ebp+var_4]   									; Copia valor referenciado por [EBP+var_4] para EBX
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
process	endp



; Attributes: bp-based frame

public is_in_check
is_in_check proc near

var_24=	byte ptr -24h
var_20=	byte ptr -20h
var_1C=	byte ptr -1Ch
var_E= byte ptr	-0Eh
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
arg_0= dword ptr  8
arg_4= dword ptr  0Ch
arg_8= dword ptr  10h

push	ebp    											; Empilha valor de EBP
mov	ebp, esp   											; Copia valor de ESP para EBP
sub	esp, 28h  ; Subtrai 28h (20 bytes, em decimal) de ESP, armazena em ESP
mov	ecx, [ebp+arg_0]  ; Copia valor referenciado por [EBP+arg_0] para ECX
mov	edx, [ebp+arg_4]  ; Copia valor referenciado por [EBP+arg_4] para EDX
mov	eax, [ebp+arg_8]  ; Copia valor referenciado por [EBP+arg_8] para EAX
mov	[ebp+var_1C], cl ; Copia Valor de AL para referenciado por [EBP+var_1C]
mov	[ebp+var_20], dl ; Copia Valor de AL para referenciado por [EBP+var_20]
mov	[ebp+var_24], al ; Copia Valor de AL para referenciado por [EBP+var_24]
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_24]								; Copia valor apontado por [EBP+var_24] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[ebp+var_B], al ; Copia Valor de AL para referenciado por [EBP+var_B]
mov	edx, ds:cells_side
movzx	eax, [ebp+var_24]								; Copia valor apontado por [EBP+var_24] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[ebp+var_A], al   									; Copia valor de AL para endereço apontado por [EBP+var_A]
movzx	eax, ds:cur_player
mov	[ebp+var_9], al   									; Copia valor de AL para endereço apontado por [EBP+var_9]
cmp	[ebp+var_1C], 0										; Compara valor referenciado por [EBP+var_1C], e modifica ZF e CF
setz	al	; Copia valor 1 para AL se ZF=1, copia 0 caso contrário
mov	ds:cur_player, al					; Copia valor de AL para "ds:cur_player"
mov	[ebp+var_C], 0  ; Copia 0 para referenciado por [EBP+var_C]
movzx	edx, [ebp+var_24] ; Copia valor apontado por [EBP+var_24] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    											; Empilha valor de EDX
push	eax    											;  Empilha valor de EAX
call	actual_move										; Faz uma chamada para a subrotina "actual_move"
add	esp, 10h
mov	[ebp+var_E], 0  ; Copia 0 para referenciado por [EBP+var_E]
jmp	short loc_80494AF

loc_804947E:
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_E]    							; Copia valor apontado por [EBP+var_E] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx    										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, 6		; Compara AL com 6 (em decimal), e modifica ZF e CF
jnz	short loc_80494A5									; Faz um salto curto (para um local próximo) até a subrotina "loc_80494A5". Se a ZF não estiver setada. (ZF = 0)
mov	edx, ds:cells_side
movzx	eax, [ebp+var_E]    							; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_1C]    								; Compara valor referenciado por [EBP+var_1C] com AL, e modifica ZF e CF
jz	short loc_80494B7									; Faz um salto curto (para um local próximo) até a subrotina "loc_80494B7" se a zero flag estiver setada. (ZF = 1)

loc_80494A5:
movzx	eax, [ebp+var_E]    							; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 1												; Soma 1 (em decimal) com EAX, armazena em EAX
mov	[ebp+var_E], al   									; Copia valor de AL para o endereço de memória apontado por [EDX]

loc_80494AF:
cmp	[ebp+var_E], 3Fh
jbe	short loc_804947E									; Faz um salto curto (para um local próximo) até a subrotina "loc_804947E" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
jmp	short loc_80494B8

loc_80494B7:
nop

loc_80494B8:
cmp	[ebp+var_E], 3Fh
ja	short loc_80494EE
mov	[ebp+var_D], 0  ; Copia 0 para referenciado por [EBP+var_D]
jmp	short loc_80494E8

loc_80494C4:
movzx	edx, [ebp+var_E]  ; Copia valor apontado por [EBP+var_E] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's     							; Copia valor de AL para EAX, preenchendo
sub	esp, 4   											; Subtrai 4 (em decimal) bytes do valor de ESP
push	0
push	edx    											; Empilha valor de EDX
push	eax    											; Empilha valor de EAX
call	legal_move										; Faz uma chamada para a subrotina "legal_move"
add	esp, 10h
or	[ebp+var_C], al			; Aplicar operação booleana "OR" entre valor referenciado por [EBP+var_C] e AL, armazena resultado em referência [EBP+var_C]
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's								; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 1
mov	[ebp+var_D], al ; Copia Valor de AL para referenciado por [EBP+var_D]

loc_80494E8:
cmp	[ebp+var_D], 3Fh
jbe	short loc_80494C4									; Faz um salto curto (para um local próximo) até a subrotina "loc_80494C4" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)

loc_80494EE:
movzx	edx, [ebp+var_20]  								; Copia valor apontado por [EBP+var_20] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_24]								; Copia valor apontado por [EBP+var_24] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    											; Empilha valor de EDX
push	eax    											; Empilha valor de EAX
call	actual_move										; Faz uma chamada para a subrotina "actual_move"
add	esp, 10h
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_24]								; Copia valor apontado por [EBP+var_24] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	edx, eax    										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

mov	[edx], al   										; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	edx, ds:cells_side
movzx	eax, [ebp+var_24]								; Copia valor apontado por [EBP+var_24] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	edx, eax    										; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   										; Copia valor de AL para o endereço de memória apontado por [EDX]
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	ds:cur_player, al					; Copia valor de AL para "ds:cur_player"
movzx	eax, [ebp+var_C]    							; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
is_in_check endp



; Attributes: bp-based frame

public legal_move
legal_move proc	near

var_24=	byte ptr -24h
var_20=	byte ptr -20h
var_1C=	byte ptr -1Ch
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_4= dword ptr -4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch
arg_8= dword ptr  10h

push	ebp    ; Empilha valor de EBP
mov	ebp, es   ; Empilha valor EBX
push	ebx
sub	esp, 24h
mov	ecx, [ebp+arg_0]  ; Copia valor referenciado por [EBP+arg_0] para ECX
mov	edx, [ebp+arg_4]  ; Copia valor referenciado por [EBP+arg_4] para EDX
mov	eax, [ebp+arg_8]  ; Copia valor referenciado por [EBP+arg_8] para EAX
mov	[ebp+var_1C], cl ; Copia Valor de AL para referenciado por [EBP+var_1C]
mov	[ebp+var_20], dl ; Copia Valor de AL para referenciado por [EBP+var_20]
mov	[ebp+var_24], al ; Copia Valor de AL para referenciado por [EBP+var_24]
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	is_own_piece						; Faz uma chamada para a subrotina "is_own_piece"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_804956D					; Faz um salto curto (para um local próximo) até a subrotina "loc_804956D". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804956D:
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	is_own_piece						; Faz uma chamada para a subrotina "is_own_piece"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_804958B						; Faz um salto curto (para um local próximo) até a subrotina "loc_804958B" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804958B:
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_20]    ; Compara valor referenciado por [EBP+var_20] com AL, e modifica ZF e CF
jnz	short loc_804959E					; Faz um salto curto (para um local próximo) até a subrotina "loc_804959E". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804959E:
cmp	[ebp+var_1C], 3Fh
jbe	short loc_80495AE							; Faz um salto curto (para um local próximo) até a subrotina "loc_80495AE" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_80495AE:
cmp	[ebp+var_20], 3Fh
jbe	short loc_80495BE							; Faz um salto curto (para um local próximo) até a subrotina "loc_80495BE" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_80495BE:
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
mov	[ebp+var_D], al ; Copia Valor de AL para referenciado por [EBP+var_D]
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	[ebp+var_C], al
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
mov	[ebp+var_B], al ; Copia Valor de AL para referenciado por [EBP+var_B]
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	[ebp+var_A], al   ; Copia valor de AL para endereço apontado por [EBP+var_A]
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	eax, 6		; switch 7 cases
ja	loc_8049D0B	; default
mov	eax, ds:off_804A66C[eax*4]
jmp	eax		; switch jump

loc_804960A:		; case 0x0
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049614:		; case 0x1
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute								;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
jbe	short loc_804963D							; Faz um salto curto (para um local próximo) até a subrotina "loc_804963D" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804963D:
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_B]
jl	short loc_8049659
mov	edx, ds:cells_side
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049675							; Faz um salto curto (para um local próximo) até a subrotina "loc_8049675" se a zero flag estiver setada. (ZF = 1)

loc_8049659:
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_B]
jg	short loc_804967F
mov	edx, ds:cells_side
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_804967F							; Faz um salto curto (para um local próximo) até a subrotina "loc_804967F" se a zero flag estiver setada. (ZF = 1)

loc_8049675:
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804967F:
movzx	eax, [ebp+var_C]    ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_A]
jnz	loc_804977A								; Faz um salto até a subrotina "loc_804977A" se a zero flag não estiver setada. (ZF = 0)
movzx	edx, [ebp+var_D]  ; Copia valor apontador por [EBP+var_D] para EDX, estendendo a parte mais significativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute								;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
jnz	short loc_80496CC							; Faz um salto curto (para um local próximo) até a subrotina "loc_80496CC". Se a ZF não estiver setada. (ZF = 0)
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	loc_804982A
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_80496CC:
movzx	edx, [ebp+var_D]  ; Copia valor apontador por [EBP+var_D] para EDX, estendendo a parte mais significativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 2
jnz	loc_8049770								; Faz um salto até a subrotina "loc_8049770" se a zero flag não estiver setada. (ZF = 0)
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_804974B					; Faz um salto curto (para um local próximo) até a subrotina "loc_804974B". Se a ZF não estiver setada. (ZF = 0)
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	ecx, [ebp+var_1C] ; Copia valor apontado por [EBP+var_1C] para ECX, estendendo a parte mais sigificativa de ECX com 0's
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
mov	ecx, eax    ; Copia valor de ECX para EAX
shr	ecx, 1Fh  	; Desloca valor de 1FH em bits para à direita
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
sar	eax, 1		; Desloca valor de 1FH em bits para à esquerda
add	eax, edx    ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_804974B					; Faz um salto curto (para um local próximo) até a subrotina "loc_804974B". Se a ZF não estiver setada. (ZF = 0)
movsx	edx, [ebp+var_D]
mov	ecx, ds:cells_side		; Copia valor de "ds:cells_side" para ECX
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_8049742					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049742". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 1    ; Copia 1 para EAX
jmp	short loc_8049747

loc_8049742:
mov	eax, 6

loc_8049747:
cmp	edx, eax    ; Compara valor de EDX com EAX, e modifica ZF e CF
jz	short loc_8049755						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049755" se a zero flag estiver setada. (ZF = 1)

loc_804974B:
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049755:
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	loc_804982A
movzx	eax, [ebp+var_C]    ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 8					; Soma 8 (em decimal) com EAX, armazena em EAX
mov	ds:en_passant_flag, al  ; Copia valor de AL para "ds:en_passant_flag"
jmp	loc_804982A									; Faz um salto incondicional até a subrotina "loc_804982A"

loc_8049770:
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804977A:
movzx	edx, [ebp+var_D]  ; Copia valor apontador por [EBP+var_D] para EDX, estendendo a parte mais significativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
jz	short loc_80497A3						; Faz um salto curto (para um local próximo) até a subrotina "loc_80497A3" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_80497A3:
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_804982A					; Faz um salto curto (para um local próximo) até a subrotina "loc_804982A". Se a ZF não estiver setada. (ZF = 0)
movsx	edx, [ebp+var_A]				; Copia valor apontado por [EBP+var_A] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, ds:en_passant_flag
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	edx, eax    ; Compara valor de EDX com EAX, e modifica ZF e CF
jnz	short loc_8049820					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049820". Se a ZF não estiver setada. (ZF = 0)
movsx	edx, [ebp+var_B]				; Copia valor apontado por [EBP+var_B] para EDX, estendendo a parte mais sigificativa de EDX com 0's
mov	ecx, ds:cells_side		; Copia valor de "ds:cells_side" para ECX
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_80497E6					; Faz um salto curto (para um local próximo) até a subrotina "loc_80497E6". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 5
jmp	short loc_80497EB

loc_80497E6:
mov	eax, 2	; Copia 2 para EAX

loc_80497EB:
cmp	edx, eax    ; Compara valor de EDX com EAX, e modifica ZF e CF
jnz	short loc_8049820					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049820". Se a ZF não estiver setada. (ZF = 0)
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	short loc_804982A						; Faz um salto curto (para um local próximo) até a subrotina "loc_804982A" se a zero flag estiver setada. (ZF = 1)
mov	ebx, ds:cells_type		; Copia valor de "ds:cells_type" para EBX
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, al   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ebx  ; Soma EBX com EAX, armazena em EAX
mov	byte ptr [eax],	0   ; Copia O para o 1º byte do valor apontado por [EAX] para EAX
jmp	short loc_804982A

loc_8049820:
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804982A:
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	loc_8049CF8
movsx	edx, [ebp+var_B]				; Copia valor apontado por [EBP+var_B] para EDX, estendendo a parte mais sigificativa de EDX com 0's
mov	ecx, ds:cells_side		; Copia valor de "ds:cells_side" para ECX
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_8049852					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049852". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 7
jmp	short loc_8049857

loc_8049852:
mov	eax, 0    ; Copia 0 para EAX

loc_8049857:
cmp	edx, eax    ; Compara valor de EDX com EAX, e modifica ZF e CF
jnz	loc_8049CF8								; Faz um salto até a subrotina "loc_8049CF8" se a zero flag não estiver setada. (ZF = 0)
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
lea	ebx, [edx+eax]
call	promote_pawn					; Faz uma chamada para a subrotina "promote_pawn"
mov	[ebx], al ; Copia Valor de AL para referenciado por [EBX]
jmp	loc_8049CF8									; Faz um salto incondicional até a subrotina "loc_8049CF8"

loc_8049878:		; case 0x2
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
jnz	short loc_80498BA					; Faz um salto curto (para um local próximo) até a subrotina "loc_80498BA". Se a ZF não estiver setada. (ZF = 0)
movzx	edx, [ebp+var_D]  ; Copia valor apontador por [EBP+var_D] para EDX, estendendo a parte mais significativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 2
jz	loc_8049CFB

loc_80498BA:
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 2
jnz	short loc_80498FC					; Faz um salto curto (para um local próximo) até a subrotina "loc_80498FC". Se a ZF não estiver setada. (ZF = 0)
movzx	edx, [ebp+var_D]  ; Copia valor apontador por [EBP+var_D] para EDX, estendendo a parte mais significativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
jz	loc_8049CFB

loc_80498FC:
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049906:		; case 0x3
movzx	edx, [ebp+var_20]						; Copia valor apontado por [EBP+var_20] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
push	1		; Empilha 1
push	0		; Empilha 0
push	edx		; Empilha valor de EDX
push	eax		; Empilha valor de EAX
call	is_path_clear					; Faz uma chamada para a subrotina "is_path_clear"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	loc_8049CFE								; Faz um salto até a subrotina "loc_8049CFE" se a zero flag não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_804992E:		; case 0x4
movzx	edx, [ebp+var_20]  								; Copia valor apontado por [EBP+var_20] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_1C]   							; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
push	0
push	1
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	is_path_clear					; Faz uma chamada para a subrotina "is_path_clear"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_8049952					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049952". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049952:
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	loc_8049D01
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	0
push	0
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_1C]    ; Compara valor de EDX com EAX, e modifica ZF e CF
jnz	short loc_804997F					; Faz um salto curto (para um local próximo) até a subrotina "loc_804997F". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
or	eax, 1
mov	ds:castle_flag,	al

loc_804997F:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	7
push	0
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_1C]    ; Compara valor de EDX com EAX, e modifica ZF e CF
jnz	short loc_80499A2					; Faz um salto curto (para um local próximo) até a subrotina "loc_80499A2". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
or	eax, 2
mov	ds:castle_flag,	al

loc_80499A2:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	0
push	7
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_1C]
jnz	short loc_80499C5					; Faz um salto curto (para um local próximo) até a subrotina "loc_80499C5". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag
or	eax, 4
mov	ds:castle_flag,	al

loc_80499C5:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	7
push	7
call	to_pos									; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_1C]
jnz	loc_8049D01									; Faz um salto até a subrotina "loc_8049D01" se a zero flag não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag
or	eax, 8
mov	ds:castle_flag,	al
jmp	loc_8049D01									; Faz um salto incondicional até a subrotina "loc_8049D01"

loc_80499F1:		; case 0x5
movzx	edx, [ebp+var_20]   					; Copia valor apontado por [EBP+var_20] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
push	1
push	1
push	edx    									; Empilha valor de EDX
push	eax    									;  Empilha valor de EAX
call	is_path_clear							; Faz uma chamada para a subrotina "is_path_clear"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	loc_8049D04								; Faz um salto até a subrotina "loc_8049D04" se a zero flag não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049A19:		; case 0x6
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
ja	short loc_8049A8E
movzx	edx, [ebp+var_D]  ; Copia valor apontador por [EBP+var_D] para EDX, estendendo a parte mais significativa de EDX com 0's
movzx	eax, [ebp+var_B]  ; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 1		; Compara AL com 1 (em decimal), e modifica ZF e CF
ja	short loc_8049A8E
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	loc_8049D07
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 4
mov	edx, 1
mov	ecx, eax    ; Copia valor de ECX para EAX
shl	edx, cl     ; Desloca valor de CL em bits para à esquerda
mov	eax, edx    ; Copia valor de EDX para EAX
mov	edx, eax    ; Copia valor de EAX parar EDX
movzx	eax, ds:castle_flag ; Copia valor de DS para EAX, estendendo a parte mais significativa de EAX com zeros (Adiciona 0's à esquerda).   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
or	eax, edx
mov	ds:castle_flag,	al
jmp	loc_8049D07									; Faz um salto incondicional até a subrotina "loc_8049D07"

loc_8049A8E:
cmp	[ebp+var_C], 4
jnz	short loc_8049AB3					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049AB3". Se a ZF não estiver setada. (ZF = 0)
movsx	edx, [ebp+var_D]
movzx	eax, ds:cur_player
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_8049AAA					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049AAA". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	short loc_8049AAF

loc_8049AAA:
mov	eax, 7

loc_8049AAF:
cmp	edx, eax    ; Compara valor de EDX com EAX, e modifica ZF e CF
jz	short loc_8049ABD						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049ABD" se a zero flag estiver setada. (ZF = 1)

loc_8049AB3:
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049ABD:
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
movzx	edx, al   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 4
mov	ecx, eax    ; Copia valor de ECX para EAX
sar	edx, cl
mov	eax, edx    ; Copia valor de EDX para EAX
and	eax, 1
test	eax, eax   ; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8049AEB						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049AEB" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049AEB:
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_B]
jz	short loc_8049AFE						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049AFE" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049AFE:
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
cmp	al, 2
jz	short loc_8049B27						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049B27" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049B27:
movsx	edx, [ebp+var_A]				; Copia valor apontado por [EBP+var_A] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movsx	eax, [ebp+var_C]
mov	ebx, edx
sub	ebx, eax
movzx	edx, [ebp+var_C]
movzx	eax, [ebp+var_A]					; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute						;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
movzx	ecx, al   ; Copia valor de AL para ECX, estendendo a parte mais sigificativa de ECX com 0's
mov	eax, ebx    ; Copia valor de EBX para EAX
cdq
idiv	ecx
mov	[ebp+var_9], al   ; Copia valor de AL para endereço apontado por [EBP+var_9]
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
movzx	edx, al   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
lea	ecx, [eax+eax]
cmp	[ebp+var_9], 1
setz	al	; Copia valor 1 para AL se ZF=1, copia 0 caso contrário
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
mov	ecx, eax    ; Copia valor de ECX para EAX
sar	edx, cl
mov	eax, edx    ; Copia valor de EDX para EAX
and	eax, 1
test	eax, eax   ; Realiza operação booleana "AND" sem armazenar valor, seta ZF=1 se o resultado só tiver bit 0, ZF=0 caso não
jz	short loc_8049B93						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049B93" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049B93:
movzx	eax, ds:cur_player
shl	eax, 3
lea	edx, ds:0[eax*8]
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
cmp	[ebp+var_9], 1
jnz	short loc_8049BB5					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049BB5". Se a ZF não estiver setada. (ZF = 0)
mov	edx, 7
jmp	short loc_8049BBA

loc_8049BB5:
mov	edx, 0

loc_8049BBA:
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	edx, al   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
push	0
push	1
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	is_path_clear					; Faz uma chamada para a subrotina "is_path_clear"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jnz	short loc_8049BDF					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049BDF". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049BDF:
movzx	ecx, [ebp+var_1C] ; Copia valor apontado por [EBP+var_1C] para ECX, estendendo a parte mais sigificativa de ECX com 0's
movzx	edx, [ebp+var_1C]	; Copia valor apontado por [EBP+var_1C] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   ; Subtrai 4 (em decimal) bytes do valor de ESP
push	ecx    ; Empilha valor de ECX
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	is_in_check										; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049C0D						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049C0D" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049C0D:
movzx	edx, [ebp+var_1C]	; Copia valor apontado por [EBP+var_1C] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	ecx, al   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, [ebp+var_1C]	; Copia valor apontado por [EBP+var_1C] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   ; Subtrai 4 (em decimal) bytes do valor de ESP
push	ecx    ; Empilha valor de ECX
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	is_in_check										; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049C44						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049C44" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049C44:
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
lea	edx, [eax+eax]
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	ecx, al   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, [ebp+var_1C]	; Copia valor apontado por [EBP+var_1C] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 4   ; Subtrai 4 (em decimal) bytes do valor de ESP
push	ecx    ; Empilha valor de ECX
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	is_in_check										; Faz uma chamada para a subrotina "is_in_check"
add	esp, 10h
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049C7E						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049C7E" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_8049DE9									; Faz um salto incondicional até a subrotina "loc_8049DE9"

loc_8049C7E:
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	loc_8049D0A
movzx	edx, [ebp+var_1C]	; Copia valor apontado por [EBP+var_1C] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_9]  ; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	edx, al   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, ds:cur_player
shl	eax, 3
lea	ecx, ds:0[eax*8]
sub	ecx, eax
mov	eax, ecx    ; Copia valor de ECX para EAX
cmp	[ebp+var_9], 1
jnz	short loc_8049CB7					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049CB7". Se a ZF não estiver setada. (ZF = 0)
mov	ecx, 7
jmp	short loc_8049CBC

loc_8049CB7:
mov	ecx, 0

loc_8049CBC:
add	eax, ecx    ; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	actual_move										; Faz uma chamada para a subrotina "actual_move"
add	esp, 10h
movzx	eax, ds:cur_player
movzx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, 4
mov	edx, 1
mov	ecx, eax    ; Copia valor de ECX para EAX
shl	edx, cl     ; Desloca valor de CL em bits para à esquerda
mov	eax, edx    ; Copia valor de EDX para EAX
mov	edx, eax    ; Copia valor de EAX parar EDX
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).   ; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
or	eax, edx
mov	ds:castle_flag,	al
jmp	short loc_8049D0A

loc_8049CF8:
nop		;No Operation
jmp	short loc_8049D0B ; default

loc_8049CFB:
nop		;No Operation
jmp	short loc_8049D0B ; default

loc_8049CFE:
nop		;No Operation
jmp	short loc_8049D0B ; default

loc_8049D01:
nop		;No Operation
jmp	short loc_8049D0B ; default

loc_8049D04:
nop		;No Operation
jmp	short loc_8049D0B ; default

loc_8049D07:
nop		;No Operation
jmp	short loc_8049D0B ; default

loc_8049D0A:
nop		;No Operation

loc_8049D0B:		; default
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jz	loc_8049DE4
movzx	edx, [ebp+var_20]  								; Copia valor apontado por [EBP+var_20] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    ; Empilha valor de EDX
push	eax    ;  Empilha valor de EAX
call	actual_move										; Faz uma chamada para a subrotina "actual_move"
add	esp, 10h
movzx	eax, ds:en_passant_flag
cmp	al, 0FFh
jz	short loc_8049D51						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049D51" se a zero flag estiver setada. (ZF = 1)
movzx	eax, ds:en_passant_flag
cmp	al, 7
jbe	short loc_8049D51							; Faz um salto curto (para um local próximo) até a subrotina "loc_8049D51" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
movzx	eax, ds:en_passant_flag
sub	eax, 8
mov	ds:en_passant_flag, al  ; Copia valor de AL para "ds:en_passant_flag"
jmp	short loc_8049D58

loc_8049D51:
mov	ds:en_passant_flag, 0FFh

loc_8049D58:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	0
push	0
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_20]    ; Compara AL com valor referenciado por [EBP+var_20], e modifica ZF e CF
jnz	short loc_8049D7B					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049D7B". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
or	eax, 1
mov	ds:castle_flag,	al

loc_8049D7B:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	7
push	0
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_20]    ; Compara valor referenciado por [EBP+var_1C] com AL, e modifica ZF e CF
jnz	short loc_8049D9E					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049D9E". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
or	eax, 2
mov	ds:castle_flag,	al

loc_8049D9E:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	0
push	7
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_20]    ; Compara valor referenciado por [EBP+var_1C] com AL, e modifica ZF e CF
jnz	short loc_8049DC1					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049DC1". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
or	eax, 4
mov	ds:castle_flag,	al

loc_8049DC1:
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	7
push	7
call	to_pos							; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
cmp	al, [ebp+var_20]    ; Compara valor referenciado por [EBP+var_1C] com AL, e modifica ZF e CF
jnz	short loc_8049DE4					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049DE4". Se a ZF não estiver setada. (ZF = 0)
movzx	eax, ds:castle_flag ; Copia valor de AL para EDX, estendendo a parte mais significativa de EDX com zeros (Adiciona 0's à esquerda).
or	eax, 8
mov	ds:castle_flag,	al

loc_8049DE4:
mov	eax, 1    ; Copia 1 para EAX

loc_8049DE9:
mov	ebx, [ebp+var_4]    ; Copia valor referenciado por [EBP+var_4] para EBX
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
legal_move endp



; Attributes: bp-based frame

public is_own_piece
is_own_piece proc near

var_4= byte ptr	-4
arg_0= dword ptr  8

push	ebp    ; Empilha valor de EBP
mov	ebp, esp    ; Copia valor de ESP para EBP
sub	esp, 4   ; Subtrai 4 (em decimal) bytes do valor de ESP
mov	eax, [ebp+arg_0]    ; Copia valor referenciado por [EBP+var_4] para EAX
mov	[ebp+var_4], al   ; Copia valor de AL para endereço apontado por [EBP+var_4]
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_4]    ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] ; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al   ; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049E2E						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049E2E" se a zero flag estiver setada. (ZF = 1)
mov	edx, ds:cells_side
movzx	eax, [ebp+var_4]    ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     ; Soma valor de EDX com EAX, e armazena em EDX
movzx	edx, byte ptr [eax]
movzx	eax, ds:cur_player
cmp	dl, al
jnz	short loc_8049E2E					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049E2E". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 1    ; Copia 1 para EAX
jmp	short locret_8049E33

loc_8049E2E:
mov	eax, 0    ; Copia 0 para EAX

locret_8049E33:
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
is_own_piece endp



; Attributes: bp-based frame

public is_path_clear
is_path_clear proc near

var_28=	byte ptr -28h
var_24=	byte ptr -24h
var_20=	byte ptr -20h
var_1C=	byte ptr -1Ch
var_13=	byte ptr -13h
var_12=	byte ptr -12h
var_11=	byte ptr -11h
var_10=	byte ptr -10h
var_F= byte ptr	-0Fh
var_E= byte ptr	-0Eh
var_D= byte ptr	-0Dh
var_C= byte ptr	-0Ch
var_B= byte ptr	-0Bh
var_A= byte ptr	-0Ah
var_9= byte ptr	-9
var_4= dword ptr -4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch
arg_8= dword ptr  10h
arg_C= dword ptr  14h

push	ebp    ; Empilha valor de EBP
mov	ebp, es   ; Empilha valor EBX
push	ebx
sub	esp, 24h
mov	ebx, [ebp+arg_0]
mov	ecx, [ebp+arg_4]
mov	edx, [ebp+arg_8]
mov	eax, [ebp+arg_C]
mov	[ebp+var_1C], bl
mov	[ebp+var_20], cl
mov	[ebp+var_24], dl
mov	[ebp+var_28], al
cmp	[ebp+var_1C], 3Fh
jbe	short loc_8049E73							; Faz um salto curto (para um local próximo) até a subrotina "loc_8049E73" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
push	offset __PRETTY_FUNCTION___2817	; "is_path_clear"
push	1D5h
push	offset aProgram_c ; "program.c"
push	offset a0Src_posSrc_po ; "0 <= src_pos && src_pos < BOARD_SIZE"
call	___assert_fail							; Faz uma chamada para a subrotina "___assert_fail"

loc_8049E73:
cmp	[ebp+var_20], 3Fh
jbe	short loc_8049E92							; Faz um salto curto (para um local próximo) até a subrotina "loc_8049E92" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
push	offset __PRETTY_FUNCTION___2817	; "is_path_clear"
push	1D6h
push	offset aProgram_c ; "program.c"
push	offset a0Des_posDes_po ; "0 <= des_pos && des_pos < BOARD_SIZE"
call	___assert_fail							; Faz uma chamada para a subrotina "___assert_fail"

loc_8049E92:
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
mov	[ebp+var_12], al
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	[ebp+var_11], al
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
shr	al, 3
mov	[ebp+var_10], al
movzx	eax, [ebp+var_20]	; Copia valor apontado por [EBP+var_20] para EAX, estendendo a parte mais sigificativa de EAX com 0's
and	eax, 7
mov	[ebp+var_F], al
movzx	edx, [ebp+var_12]
movzx	eax, [ebp+var_10]   ; Copia valor apontado por [EBP+var_10] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute							;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
mov	[ebp+var_E], al   ; Copia valor de AL para o endereço de memória apontado por [EBP+var_E]
movzx	edx, [ebp+var_11]   ; Copia valor apontado por [EBP+var_11] para EDX, estendendo a parte mais sigificativa de EDX com 0's
movzx	eax, [ebp+var_F]    ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	eax, al   ; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
push	eax    ;  Empilha valor de EAX
call	absolute							;Faz uma chamada para a subrotina "absolute"
add	esp, 10h
mov	[ebp+var_D], al ; Copia Valor de AL para referenciado por [EBP+var_D]
cmp	[ebp+var_E], 0
jz	short loc_8049F15						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049F15" se a zero flag estiver setada. (ZF = 1)
cmp	[ebp+var_D], 0
jz	short loc_8049F15						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049F15" se a zero flag estiver setada. (ZF = 1)
movzx	eax, [ebp+var_E]    ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_D]
jz	short loc_8049F15						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049F15" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    ; Copia 0 para EAX
jmp	loc_804A038									; Faz um salto incondicional até a subrotina "loc_804A038"

loc_8049F15:
movzx	eax, [ebp+var_1C]   ; Copia valor apontado por [EBP+var_1C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_20]    ; Compara valor referenciado por [EBP+var_1C] com AL, e modifica ZF e CF
jnz	short loc_8049F28					; Faz um salto curto (para um local próximo) até a subrotina "loc_8049F28". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 1    ; Copia 1 para EAX
jmp	loc_804A038									; Faz um salto incondicional até a subrotina "loc_804A038"

loc_8049F28:
movzx	eax, [ebp+var_D]  ; Copia valor apontado por [EBP+var_D] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, [ebp+var_E]  ; Copia valor apontado por [EBP+var_E] para EDX, estendendo a parte mais sigificativa de EDX com 0's
cmp	[ebp+var_E], al
cmovge	eax, edx
mov	[ebp+var_C], al
cmp	[ebp+var_E], 0
jz	short loc_8049F54						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049F54" se a zero flag estiver setada. (ZF = 1)
movsx	edx, [ebp+var_10]
movsx	eax, [ebp+var_12]
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	ebx, [ebp+var_C]
cdq
idiv	ebx
jmp	short loc_8049F59

loc_8049F54:
mov	eax, 0    ; Copia 0 para EAX

loc_8049F59:
mov	[ebp+var_B], al ; Copia Valor de AL para referenciado por [EBP+var_B]
cmp	[ebp+var_D], 0
jz	short loc_8049F77						; Faz um salto curto (para um local próximo) até a subrotina "loc_8049F77" se a zero flag estiver setada. (ZF = 1)
movsx	edx, [ebp+var_F]
movsx	eax, [ebp+var_11]
sub	edx, eax    ; Subtrai valor de EAX de EDX, e armazena em EDX
mov	eax, edx    ; Copia valor de EDX para EAX
movsx	ebx, [ebp+var_C]
cdq
idiv	ebx
jmp	short loc_8049F7C

loc_8049F77:
mov	eax, 0    ; Copia 0 para EAX

loc_8049F7C:
mov	[ebp+var_A], al   										; Copia valor de AL para endereço apontado por [EBP+var_A]
cmp	[ebp+var_B], 0
setnz	dl
cmp	[ebp+var_A], 0
setnz	al
and	eax, edx    											; Aplica a operação booleana AND entre valores de EAX e EDX, armazena resultado em EAX
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049FA3										; Faz um salto curto (para um local próximo) até a subrotina "loc_8049FA3" se a zero flag estiver setada. (ZF = 1)
cmp	[ebp+var_28], 0
jnz	short loc_8049FA3										; Faz um salto curto (para um local próximo) até a subrotina "loc_8049FA3". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    												; Copia 0 para EAX
jmp	loc_804A038												; Faz um salto incondicional até a subrotina "loc_804A038"

loc_8049FA3:
cmp	[ebp+var_B], 0
setnz	dl
cmp	[ebp+var_A], 0
setnz	al
xor	eax, edx
test	al, al   											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_8049FC4										; Faz um salto curto (para um local próximo) até a subrotina "loc_8049FC4" se a zero flag estiver setada. (ZF = 1)
cmp	[ebp+var_24], 0   ; Compara valor referenciado por [EBP+var_24], e modifica ZF e CF
jnz	short loc_8049FC4										; Faz um salto curto (para um local próximo) até a subrotina "loc_8049FC4". Se a ZF não estiver setada. (ZF = 0)
mov	eax, 0    ; Copia 0 para EAX
jmp	short loc_804A038

loc_8049FC4:
mov	[ebp+var_13], 1
jmp	short loc_804A02A

loc_8049FCA:
movzx	eax, [ebp+var_A]									; Copia valor apontado por [EBP+var_A] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	edx, [ebp+var_13]
imul	eax, edx   											; Realiza uma multiplicação com sinal  entre EAX e EDX, armazena resultado em EAX
mov	edx, eax    											; Copia valor de EAX parar EDX
movzx	eax, [ebp+var_11]   								; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	edx, al   											; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
movzx	eax, [ebp+var_B]  									; Copia valor apontado por [EBP+var_B] para EAX, estendendo a parte mais sigificativa de EAX com 0's

movzx	ecx, [ebp+var_13]
imul	eax, ecx
mov	ecx, eax    											; Copia valor de ECX para EAX
movzx	eax, [ebp+var_12]
add	eax, ecx    											; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, al   											; Copia valor de AL para EAX, estendendo a parte mais sigificativa de EAX com 0's
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
push	edx    												; Empilha valor de EDX
push	eax    												; Empilha valor de EAX
call	to_pos												; Faz uma chamada para a subrotina "to_pos"
add	esp, 10h
mov	[ebp+var_9], al   										; Copia valor de AL para endereço apontado por [EBP+var_9]
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movsx	eax, [ebp+var_9]    								; Copia valor apontado por [EBP+var_9] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
movzx	eax, byte ptr [eax] 								; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
test	al, al  											; Aplica a operação booleana "AND" entre valores AL e AL, seta ZF=1 a cada bit 1-1 comparado. Não armazena valor em registrador
jz	short loc_804A020										; Faz um salto curto (para um local próximo) até a subrotina "loc_804A020" se a zero flag estiver setada. (ZF = 1)
mov	eax, 0    												; Copia 0 para EAX
jmp	short loc_804A038

loc_804A020:
movzx	eax, [ebp+var_13]
add	eax, 1
mov	[ebp+var_13], al

loc_804A02A:
movzx	eax, [ebp+var_13]
cmp	al, [ebp+var_C]
jl	short loc_8049FCA
mov	eax, 1    												; Copia 1 para EAX

loc_804A038:
mov	ebx, [ebp+var_4]    									; Copia valor referenciado por [EBP+var_4] para EBX
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
is_path_clear endp



; Attributes: bp-based frame

public actual_move
actual_move proc near

var_10=	byte ptr -10h
var_C= byte ptr	-0Ch
arg_0= dword ptr  8
arg_4= dword ptr  0Ch

push	ebp    												; Empilha valor de EBP
mov	ebp, esp   												; Copia valor de ESP para EBP
sub	esp, 18h
mov	edx, [ebp+arg_0]
mov	eax, [ebp+arg_4]
mov	[ebp+var_C], dl
mov	[ebp+var_10], al
cmp	[ebp+var_C], 3Fh
jbe	short loc_804A06E										; Faz um salto curto (para um local próximo) até a subrotina "loc_804A06E" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
push	offset __PRETTY_FUNCTION___2836	; "actual_move"
push	1F8h
push	offset aProgram_c ; "program.c"
push	offset a0Src_posSrc_po ; "0 <= src_pos && src_pos < BOARD_SIZE"
call	___assert_fail										; Faz uma chamada para a subrotina "___assert_fail"

loc_804A06E:
cmp	[ebp+var_10], 3Fh
jbe	short loc_804A08D										; Faz um salto curto (para um local próximo) até a subrotina "loc_804A08D" se a cf e zf flag estiverem setadas. No caso, significa que irá saltar se o resultado da comparação indicar menor ou igual. (O sinal não interere) (CF = 1 ZF = 1)
push	offset __PRETTY_FUNCTION___2836	; "actual_move"
push	1F9h
push	offset aProgram_c ; "program.c"
push	offset a0Des_posDes_po ; "0 <= des_pos && des_pos < BOARD_SIZE"
call	___assert_fail										; Faz uma chamada para a subrotina "___assert_fail"

loc_804A08D:
movzx	eax, [ebp+var_C]   									; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
cmp	al, [ebp+var_10]
jz	short loc_804A0E1										; Faz um salto curto (para um local próximo) até a subrotina "loc_804A0E1" se a zero flag estiver setada. (ZF = 1)
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_10]  									; Copia valor apontado por [EBP+var_10] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
mov	ecx, ds:cells_type
movzx	eax, [ebp+var_C]    								; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    											; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, byte ptr [eax] 								; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	edx, ds:cells_side
movzx	eax, [ebp+var_10]   								; Copia valor apontado por [EBP+var_10] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	edx, eax    											; Soma valor de EDX com EAX, e armazena em EDX
mov	ecx, ds:cells_side										; Copia valor de "ds:cells_side" para ECX
movzx	eax, [ebp+var_C]    								; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, ecx    											; Soma valor de EAX com ECX, e armazena em EAX
movzx	eax, byte ptr [eax] 								; Copia 1 byte do valor apontado por [EAX] para EAX, estendendo a parte mais sigificativa de EAX com 0's
mov	[edx], al   											; Copia valor de AL para o endereço de memória apontado por [EDX]
mov	edx, ds:cells_type										; Copia valor de "ds:cells_type" para EDX
movzx	eax, [ebp+var_C]    								; Copia valor apontado por [ebp+var_C] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx     											; Soma valor de EDX com EAX, e armazena em EDX
mov	byte ptr [eax],	0   									; Copia O para o 1º byte do valor apontado por [EAX] para EAX
jmp	short locret_804A0E2

loc_804A0E1:
nop

locret_804A0E2:
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
actual_move endp



; Attributes: bp-based frame

public to_pos
to_pos proc near

var_8= byte ptr	-8
var_4= byte ptr	-4
arg_0= dword ptr  8
arg_4= dword ptr  0Ch

push	ebp    								; Empilha valor de EBP
mov	ebp, esp   								; Copia valor de ESP para EBP
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
mov	edx, [ebp+arg_0]
mov	eax, [ebp+arg_4]
mov	[ebp+var_4], dl
mov	[ebp+var_8], al
movzx	eax, [ebp+var_4]    				; Copia valor apontado por [EBP+var_4] para EAX, estendendo a parte mais sigificativa de EAX com 0's
lea	edx, ds:0[eax*8]
movzx	eax, [ebp+var_8]    				; Copia valor apontado por [EBP+var_8] para EAX, estendendo a parte mais sigificativa de EAX com 0's
add	eax, edx    							; Soma valor de EDX com EAX, e armazena em EDX
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
to_pos endp



; Attributes: bp-based frame

public absolute
absolute proc near

var_4= byte ptr	-4
arg_0= dword ptr  8

push	ebp    								; Empilha valor de EBP
mov	ebp, esp    							; Copia valor de ESP para EBP
sub	esp, 4  								; Subtrai 4 (em decimal) bytes do valor de ESP
mov	eax, [ebp+arg_0]    					; Copia valor referenciado por [EBP+arg_0] para EAX
mov	[ebp+var_4], al   						; Copia valor de AL para endereço apontado por [EBP+var_4]
cmp	[ebp+var_4], 0
js	short loc_804A122
mov	eax, 1    ; Copia 1 para EAX
jmp	short loc_804A127

loc_804A122:
mov	eax, 0    ; Copia 0 para EAXFFFFFFFFh

loc_804A127:
movzx	edx, [ebp+var_4]    				; Copia valor apontado por [EBP+var_4] para EDX, estendendo a parte mais sigificativa de EDX com 0's
imul	eax, edx   							; Realiza uma multiplicação com sinal  entre EAX e EDX, armazena resultado em EAX
leave			; Termina o espaço reservado para variáveis locais e retira o EBP da pilha
retn
absolute endp

; ####### FIM FUNÇÕES INTERNAS UTILIZADAS NO JOGO


public __libc_csu_init
__libc_csu_init	proc near

arg_0= dword ptr  14h
arg_4= dword ptr  18h
arg_8= dword ptr  1Ch

push	ebp    								; Empilha valor de EBP
push	edi    								; Empilha valor de EDI
push	esi    								; Empilha valor de ESI
push	ebx									; Empilha valor EBX
call	__x86_get_pc_thunk_bx				; Faz uma chamada para a subrotina "__x86_get_pc_thunk_bx"
add	ebx, 1EC7h
sub	esp, 0Ch		; Subtrai 0Ch (12 bytes, em decimal) de ESP, armazena em ESP
mov	ebp, [esp+0Ch+arg_0]
lea	esi, [ebx-0F4h]
call	_init_proc							; Faz uma chamada para a subrotina "_init_proc"
lea	eax, [ebx-0F8h]
sub	esi, eax
sar	esi, 2
test	esi, esi
jz	short loc_804A185						; Faz um salto curto (para um local próximo) até a subrotina "loc_804A185" se a zero flag estiver setada. (ZF = 1)
xor	edi, edi
lea	esi, [esi+0]

loc_804A168:     							; Copia valor de AL para EAX, preenchendo
sub	esp, 4   								; Subtrai 4 (em decimal) bytes do valor de ESP
push	[esp+10h+arg_8]
push	[esp+14h+arg_4]
push	ebp    								; Empilha valor de EBP
call	dword ptr [ebx+edi*4-0F8h]
add	edi, 1
add	esp, 10h
cmp	edi, esi    							; Compara valor de EDI com ESI, e modifica ZF e CF
jnz	short loc_804A168						; Faz um salto curto (para um local próximo) até a subrotina "short". Se a ZF não estiver setada. (ZF = 0) loc_804A168

loc_804A185:
add	esp, 0Ch
pop	ebx   									; Desempilha EBX
pop	esi   									; Desempilha ESI
pop	edi   									; Desempilha EDI
pop	ebp   									; Desempilha EBP
retn
__libc_csu_init	endp

align 10h



public __libc_csu_fini
__libc_csu_fini	proc near
rep retn
__libc_csu_fini	endp

_text ends


; Segment type:	Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use32
assume cs:_fini
;org 804A194h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _term_proc
_term_proc proc	near
push	ebx    								; Empilha valor EBX
sub	esp, 8    ; Subtrai 8 (8 bytes, em decimal) de ESP, armazena em ESP
call	__x86_get_pc_thunk_bx				; Faz uma chamada para a subrotina "__x86_get_pc_thunk_bx"
add	ebx, 1E63h
add	esp, 8
pop	ebx   									; Desempilha EBX
retn
_term_proc endp

_fini ends


; ####### VARIÁVEIS GLOBAIS E MENSAGENS UTILIZADAS NO JOGO

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata	segment	para public 'CONST' use32
assume cs:_rodata
;org 804A1C0h
public _fp_hw
_fp_hw dd 3
public _IO_stdin_used
_IO_stdin_used dd 20001h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
aTrue db 'TRUE',0
aFalse db 'FALSE',0
; char aCur_playerS[]
aCur_playerS db	'cur_player   == %s',0Ah,0
; char aHas_selectedS[]
aHas_selectedS db 'has_selected == %s',0Ah,0
; char aIs_clickedS[]
aIs_clickedS db	'is_clicked   == %s',0Ah,0
; char aSelected_posDD[]
aSelected_posDD	db 'selected_pos == (%d,%d);',0Ah,0
; char aCurrent_posDD[]
aCurrent_posDD db 'current_pos  == (%d,%d);',0Ah,0
; char aEn_paasant_fla[]
aEn_paasant_fla	db 'en_paasant_flag  == %d;',0Ah,0
; char aCastle_flagD[]
aCastle_flagD db 'castle_flag      == %d;',0Ah,0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
asc_804A2A0 db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
db '         ',0
a@@@@@ db '  @@@@@  ',0
a@@@@@_0 db '  @@@@@  ',0
a@@@@@_1 db '  @@@@@  ',0
a@@@@ db ' @@   @@ ',0
a@@@@_0	db ' @@   @@ ',0
a@@ db '     @@  ',0
a@@@@@@@ db ' @@@@@@@ ',0
a@ db '    @    ',0
a@@@@_1	db '  @@ @@  ',0
a@@@ db	'   @@@   ',0
a@_0 db	'    @    ',0
a@@@@@@@_0 db ' @@@@@@@ ',0
a@@@@@@@_1 db '@@ @@@ @@',0
a@@@@@@@@@ db '@@@@@@@@@',0
a@@@_0 db '   @@@   ',0
a@@@_1 db '   @@@   ',0
a@@@@@@@_2 db ' @@@@@@@ ',0
a@@@@@@@_3 db '@@ @@@ @@',0
a@@@@@@@_4 db '@@ @@@ @@',0
a@@@@@@@_5 db '@@ @@@ @@',0
a@@@@@@@_6 db ' @@@@@@@ ',0
a@@@@@@@_7 db ' @@@@@@@ ',0
a@@@_2 db '@   @   @',0
a@@@@@@@_8 db '@ @@@@@ @',0
a@@@_3 db '@   @   @',0
a@@@@@@@_9 db ' @@@@@@@ ',0
a@@@@@@@_10 db ' @@@@@@@ ',0
align 10h
; char aGetInputAswdFo[]
aGetInputAswdFo	db 'Get input (aswd for direction, f fo'
db 'r click) : ',0
aS db '%s',0
; void aCannotRecognis
aCannotRecognis	db 'cannot recognise the input',0
align 10h
off_804A450 dd offset loc_8048C6E ; jump table for switch statement
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048C8B
dd offset loc_8048CEB
dd offset loc_8048CE2
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CA8
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CEB
dd offset loc_8048CC5
; char aTheCurrentPawn[]
aTheCurrentPawn	db 'The current pawn is promoting... ',0
align 10h
; char aWhichTypeThatY[]
aWhichTypeThatY	db 'Which type that you want your pawn '
db 'to be... ',0
align 10h
; char aAKnightSBishop[]
aAKnightSBishop	db 'a(knight) s(bishop) d(rook) w(queen'
db ') : ',0
; char asc_804A528[]
asc_804A528 db 0Ah,0
; char asc_804A52A[]
asc_804A52A db '*****************************',0
; char aGameOverPlayer[]
aGameOverPlayer	db '* Game Over Player %c win. *',0Ah,0
; char asc_804A566[]
asc_804A566 db 0Ah
db 0Ah
db 0Ah
db 0Ah,0
; char asc_804A56B[]
asc_804A56B db '***********************',0
; char aGameOverStalem[]
aGameOverStalem	db '* Game Over Stalemate *',0
aProgram_c db 'program.c',0
aCells_typeNull	db 'cells_type != NULL',0
aAre_markedNull	db 'are_marked != NULL',0
aCells_sideNull	db 'cells_side != NULL',0
align 10h
a0Current_posCu	db '0 <= current_pos && current_pos < B'
db 'OARD_SIZE',0
align 10h
a0Selected_posS	db '0 <= selected_pos && selected_pos <'
db ' BOARD_SIZE',0
; char aChangeTurn[]
aChangeTurn db 'change turn',0
align 4
; char aPlayerDYouAreI[]
aPlayerDYouAreI	db 'Player %d, you are in check!!!',0Ah,0
off_804A66C dd offset loc_804960A ; jump table for switch statement
dd offset loc_8049614
dd offset loc_8049878
dd offset loc_8049906
dd offset loc_804992E
dd offset loc_80499F1
dd offset loc_8049A19
a0Src_posSrc_po	db '0 <= src_pos && src_pos < BOARD_SIZ'
db 'E',0
align 10h
a0Des_posDes_po	db '0 <= des_pos && des_pos < BOARD_SIZ'
db 'E',0
align 4
__PRETTY_FUNCTION___2748 db 'initialise',0
align 4
__PRETTY_FUNCTION___2764 dq 737365636F7270h
__PRETTY_FUNCTION___2817 db 'is_path_clear',0
align 4
__PRETTY_FUNCTION___2836 db 'actual_move',0
_rodata	ends

; FIM: VARIÁVEIS GLOBAIS; MENSAGENS; FUNÇÕES INTERNAS UTILIZADAS NO JOGO ########

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use32
assume cs:_eh_frame_hdr
;org 804A708h
__GNU_EH_FRAME_HDR db	 1
db  1Bh
db    3
db  3Bh	; ;
db  98h	; �
db    0
db    0
db    0
db  12h
db    0
db    0
db    0
db  48h	; H
db 0DDh	; �
db 0FFh
db 0FFh
db 0B4h	; �
db    0
db    0
db    0
db    3
db 0DFh	; �
db 0FFh
db 0FFh
db 0D8h	; �
db    0
db    0
db    0
db  5Bh	; [
db 0DFh	; �
db 0FFh
db 0FFh
db 0FCh	; �
db    0
db    0
db    0
db 0F4h	; �
db 0E4h	; �
db 0FFh
db 0FFh
db  2Ch	; ,
db    1
db    0
db    0
db  2Fh	; /
db 0E6h	; �
db 0FFh
db 0FFh
db  4Ch	; L
db    1
db    0
db    0
db 0F3h	; �
db 0E6h	; �
db 0FFh
db 0FFh
db  6Ch	; l
db    1
db    0
db    0
db 0E6h	; �
db 0E7h	; �
db 0FFh
db 0FFh
db  8Ch	; �
db    1
db    0
db    0
db    1
db 0EAh	; �
db 0FFh
db 0FFh
db 0ACh	; �
db    1
db    0
db    0
db 0DDh	; �
db 0EAh	; �
db 0FFh
db 0FFh
db 0CCh	; �
db    1
db    0
db    0
db    5
db 0EDh	; �
db 0FFh
db 0FFh
db 0F0h	; �
db    1
db    0
db    0
db  2Eh	; .
db 0EEh	; �
db 0FFh
db 0FFh
db  10h
db    2
db    0
db    0
db 0E6h	; �
db 0F6h	; �
db 0FFh
db 0FFh
db  34h	; 4
db    2
db    0
db    0
db  2Dh	; -
db 0F7h	; �
db 0FFh
db 0FFh
db  54h	; T
db    2
db    0
db    0
db  35h	; 5
db 0F9h	; �
db 0FFh
db 0FFh
db  78h	; x
db    2
db    0
db    0
db 0DCh	; �
db 0F9h	; �
db 0FFh
db 0FFh
db  98h	; �
db    2
db    0
db    0
db    1
db 0FAh	; �
db 0FFh
db 0FFh
db 0B8h	; �
db    2
db    0
db    0
db  28h	; (
db 0FAh	; �
db 0FFh
db 0FFh
db 0D8h	; �
db    2
db    0
db    0
db  88h	; �
db 0FAh	; �
db 0FFh
db 0FFh
db  24h	; $
db    3
db    0
db    0
_eh_frame_hdr ends


; Segment type:	Pure data
; Segment permissions: Read
_eh_frame segment dword	public 'CONST' use32
assume cs:_eh_frame
;org 804A7A4h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah	; z
db  52h	; R
db    0
db    1
db  7Ch	; |
db    8
db    1
db  1Bh
db  0Ch
db    4
db    4
db  88h	; �
db    1
db    0
db    0
db  20h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  8Ch	; �
db 0DCh	; �
db 0FFh
db 0FFh
db 0B0h	; �
db    0
db    0
db    0
db    0
db  0Eh
db    8
db  46h	; F
db  0Eh
db  0Ch
db  4Ah	; J
db  0Fh
db  0Bh
db  74h	; t
db    4
db  78h	; x
db    0
db  3Fh	; ?
db  1Ah
db  3Bh	; ;
db  2Ah	; *
db  32h	; 2
db  24h	; $
db  22h	; "
db  20h
db    0
db    0
db    0
db  40h	; @
db    0
db    0
db    0
db  23h	; #
db 0DEh	; �
db 0FFh
db 0FFh
db  58h	; X
db    0
db    0
db    0
db    0
db  44h	; D
db  0Ch
db    1
db    0
db  47h	; G
db  10h
db    5
db    2
db  75h	; u
db    0
db  43h	; C
db  0Fh
db    3
db  75h	; u
db  7Ch	; |
db    6
db    0
db    0
db    0
db  2Ch	; ,
db    0
db    0
db    0
db  64h	; d
db    0
db    0
db    0
db  57h	; W
db 0DEh	; �
db 0FFh
db 0FFh
db  99h	; �
db    5
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db  49h	; I
db  87h	; �
db    3
db  86h	; �
db    4
db  83h	; �
db    5
db    3
db  89h	; �
db    5
db 0C3h	; �
db  41h	; A
db 0C6h	; �
db  41h	; A
db 0C7h	; �
db  41h	; A
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  94h	; �
db    0
db    0
db    0
db 0C0h	; �
db 0E3h	; �
db 0FFh
db 0FFh
db  3Bh	; ;
db    1
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    3
db  37h	; 7
db    1
db 0C5h	; �
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db 0B4h	; �
db    0
db    0
db    0
db 0DBh	; �
db 0E4h	; �
db 0FFh
db 0FFh
db 0C4h	; �
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0C0h	; �
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db  1Ch
db    0
db    0
db    0
db 0D4h	; �
db    0
db    0
db    0
db  7Fh	; 
db 0E5h	; �
db 0FFh
db 0FFh
db 0F3h	; �
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0EFh	; �
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db  1Ch
db    0
db    0
db    0
db 0F4h	; �
db    0
db    0
db    0
db  52h	; R
db 0E6h	; �
db 0FFh
db 0FFh
db  1Bh
db    2
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    3
db  17h
db    2
db 0C5h	; �
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db  14h
db    1
db    0
db    0
db  4Dh	; M
db 0E8h	; �
db 0FFh
db 0FFh
db 0DCh	; �
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0D8h	; �
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db  20h
db    0
db    0
db    0
db  34h	; 4
db    1
db    0
db    0
db    9
db 0E9h	; �
db 0FFh
db 0FFh
db  28h	; (
db    2
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db  44h	; D
db  83h	; �
db    3
db    3
db  20h
db    2
db 0C5h	; �
db 0C3h	; �
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db  58h	; X
db    1
db    0
db    0
db  0Dh
db 0EBh	; �
db 0FFh
db 0FFh
db  29h	; )
db    1
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    3
db  25h	; %
db    1
db 0C5h	; �
db  0Ch
db    4
db    4
db  20h
db    0
db    0
db    0
db  78h	; x
db    1
db    0
db    0
db  16h
db 0ECh	; �
db 0FFh
db 0FFh
db 0B8h	; �
db    8
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db  44h	; D
db  83h	; �
db    3
db    3
db 0B0h	; �
db    8
db 0C5h	; �
db 0C3h	; �
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db  9Ch	; �
db    1
db    0
db    0
db 0AAh	; �
db 0F4h	; �
db 0FFh
db 0FFh
db  47h	; G
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    2
db  43h	; C
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db  20h
db    0
db    0
db    0
db 0BCh	; �
db    1
db    0
db    0
db 0D1h	; �
db 0F4h	; �
db 0FFh
db 0FFh
db    8
db    2
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db  44h	; D
db  83h	; �
db    3
db    3
db    0
db    2
db 0C5h	; �
db 0C3h	; �
db  0Ch
db    4
db    4
db  1Ch
db    0
db    0
db    0
db 0E0h	; �
db    1
db    0
db    0
db 0B5h	; �
db 0F6h	; �
db 0FFh
db 0FFh
db 0A7h	; �
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db    2
db 0A3h	; �
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db  1Ch
db    0
db    0
db    0
db    0
db    2
db    0
db    0
db  3Ch	; <
db 0F7h	; �
db 0FFh
db 0FFh
db  25h	; %
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db  61h	; a
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  20h
db    2
db    0
db    0
db  41h	; A
db 0F7h	; �
db 0FFh
db 0FFh
db  27h	; '
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  42h	; B
db  0Dh
db    5
db  63h	; c
db 0C5h	; �
db  0Ch
db    4
db    4
db    0
db    0
db  48h	; H
db    0
db    0
db    0
db  40h	; @
db    2
db    0
db    0
db  48h	; H
db 0F7h	; �
db 0FFh
db 0FFh
db  5Dh	; ]
db    0
db    0
db    0
db    0
db  41h	; A
db  0Eh
db    8
db  85h	; �
db    2
db  41h	; A
db  0Eh
db  0Ch
db  87h	; �
db    3
db  41h	; A
db  0Eh
db  10h
db  86h	; �
db    4
db  41h	; A
db  0Eh
db  14h
db  83h	; �
db    5
db  4Eh	; N
db  0Eh
db  20h
db  69h	; i
db  0Eh
db  24h	; $
db  44h	; D
db  0Eh
db  28h	; (
db  44h	; D
db  0Eh
db  2Ch	; ,
db  41h	; A
db  0Eh
db  30h	; 0
db  4Dh	; M
db  0Eh
db  20h
db  47h	; G
db  0Eh
db  14h
db  41h	; A
db 0C3h	; �
db  0Eh
db  10h
db  41h	; A
db 0C6h	; �
db  0Eh
db  0Ch
db  41h	; A
db 0C7h	; �
db  0Eh
db    8
db  41h	; A
db 0C5h	; �
db  0Eh
db    4
db    0
db    0
db  10h
db    0
db    0
db    0
db  8Ch	; �
db    2
db    0
db    0
db  5Ch	; \
db 0F7h	; �
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
__FRAME_END__ db    0
db    0
db    0
db    0
_eh_frame ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_jcr segment dword public 'DATA' use32
assume cs:_jcr
;org 804BF10h
__JCR_LIST__ db	   0
db    0
db    0
db    0
_jcr ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_got segment dword public 'DATA' use32
assume cs:_got
;org 804BFFCh
off_804BFFC dd offset __imp___gmon_start__
_got ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_got_plt segment dword public 'DATA' use32
assume cs:_got_plt
;org 804C000h
_GLOBAL_OFFSET_TABLE_ db    ? ;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
db    ?	;
off_804C00C dd offset printf
off_804C010 dd offset __stack_chk_fail
off_804C014 dd offset fwrite
off_804C018 dd offset malloc
off_804C01C dd offset puts
off_804C020 dd offset __libc_start_main
off_804C024 dd offset memset
off_804C028 dd offset putchar
off_804C02C dd offset __isoc99_scanf
off_804C030 dd offset __assert_fail
_got_plt ends


; Segment type:	Pure data
; Segment permissions: Read/Write
_data segment dword public 'DATA' use32
assume cs:_data
;org 804C034h
public data_start ; weak
data_start db	 0	; Alternative name is '__data_start'
db    0
db    0
db    0
public __dso_handle
__dso_handle db	   0
db    0
db    0
db    0
_data ends


; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss segment para public 'BSS' use32
assume cs:_bss
;org 804C040h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
public stderr@@GLIBC_2_0
; FILE *stderr
stderr@@GLIBC_2_0 dd ?	; Alternative name is 'stderr'
			; Copy of shared data
completed_7200 db ?
align 4
public cells_type
; void *cells_type
cells_type dd ?
public are_marked
; void *are_marked
are_marked dd ?
public current_pos
current_pos db ?
public castle_flag
castle_flag db ?
public has_selected
has_selected db	?
public cur_player
cur_player db ?
public en_passant_flag
en_passant_flag	db ?
public selected_pos
selected_pos db	?
public is_clicked
is_clicked db ?
align 4
public cells_side
; void *cells_side
cells_side dd ?
_bss ends


; Segment type:	Externs
; extern
extrn printf@@GLIBC_2_0:near
extrn __stack_chk_fail@@GLIBC_2_4:near
extrn fwrite@@GLIBC_2_0:near
extrn malloc@@GLIBC_2_0:near
extrn puts@@GLIBC_2_0:near
extrn __libc_start_main@@GLIBC_2_0:near
extrn memset@@GLIBC_2_0:near
extrn putchar@@GLIBC_2_0:near
extrn __isoc99_scanf@@GLIBC_2_7:near
extrn __assert_fail@@GLIBC_2_0:near
; int printf(const char	*,...)
extrn printf:near
extrn __stack_chk_fail:near
; size_t fwrite(const void *,size_t size,size_t	n,FILE *)
extrn fwrite:near
; void *malloc(size_t size)
extrn malloc:near
; int puts(const char *)
extrn puts:near
extrn __libc_start_main:near
; void *memset(void *,int,size_t)
extrn memset:near
; int putchar(int)
extrn putchar:near
extrn __isoc99_scanf:near
extrn __assert_fail:near
extrn _ITM_deregisterTMCloneTable ; weak
extrn __imp___gmon_start__ ; weak
extrn _Jv_RegisterClasses ; weak
extrn _ITM_registerTMCloneTable	; weak


end _start
